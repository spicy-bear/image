<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady();"></script>
    <style>
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #0ea5e9;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #0ea5e9;
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
        <!-- Fullscreen modal like Python script -->
        <div id="canvas-modal" class="hidden fixed inset-0 bg-black bg-opacity-95 z-50" style="padding-top: 50px;">
            <span class="close absolute top-4 right-8 text-white text-5xl font-bold cursor-pointer hover:text-gray-300 transition-colors" id="close-modal">&times;</span>
            <button id="modal-prev" class="hidden absolute left-4 top-1/2 transform -translate-y-1/2 text-white text-6xl font-bold cursor-pointer hover:text-gray-300 transition-colors bg-black bg-opacity-50 px-4 py-2 rounded">â€¹</button>
            <button id="modal-next" class="hidden absolute right-4 top-1/2 transform -translate-y-1/2 text-white text-6xl font-bold cursor-pointer hover:text-gray-300 transition-colors bg-black bg-opacity-50 px-4 py-2 rounded">â€º</button>
            <canvas id="modal-canvas" class="block mx-auto" style="max-width: 90%; max-height: 90vh; width: auto; height: auto;"></canvas>
            <div id="modal-info" class="hidden absolute bottom-4 left-1/2 transform -translate-x-1/2 text-white text-sm bg-black bg-opacity-70 px-4 py-2 rounded"></div>
        </div>
        
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-sky-400"></h1>
            <p class="text-gray-400"></p>
        </header>

        <div id="loader" class="text-center p-8">
            <div class="inline-block h-8 w-8 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] text-sky-400 motion-reduce:animate-[spin_1.5s_linear_infinite]" role="status">
                <span class="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">Loading...</span>
            </div>
            <p class="mt-4 text-lg">Loading OpenCV.js...</p>
        </div>

        <main id="app-content" class="hidden">
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
                <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">Controls</h2>
                <div class="grid grid-cols-1 md:grid-cols-1 gap-6">
                    <div>
                        <label for="video-input" class="block text-sm font-medium mb-2">Load Drone Video</label>
                        <input type="file" id="video-input" accept="video/*" class="block w-full text-sm text-gray-300
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-lg file:border-0
                            file:text-sm file:font-semibold
                            file:bg-sky-600 file:text-white
                            hover:file:bg-sky-700
                            file:cursor-pointer
                        ">
                        <div id="video-info" class="mt-3 p-3 bg-gray-700 rounded hidden">
                            <div class="text-xs text-gray-300 space-y-1">
                                <div><strong>Duration:</strong> <span id="video-duration">-</span></div>
                                <div><strong>Total Frames:</strong> <span id="video-frames">-</span></div>
                                <div><strong>FPS:</strong> <span id="video-fps">-</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
                <h2 class="text-xl font-semibold mb-2">Detection Methods</h2>
                <p class="text-sm text-gray-400 mb-4">Enable multiple methods for comprehensive detection</p>

                <!-- Smart Terrain Filter -->
                <div class="bg-orange-900 bg-opacity-20 p-4 rounded mb-4 border-2 border-orange-500">
                    <div class="flex items-center justify-between mb-3">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="enable-smart-filter" class="w-5 h-5">
                            <span class="text-orange-400 font-semibold">Smart Terrain Filter (Reduce Noise)</span>
                        </label>
                        <button id="analyze-terrain-btn" class="bg-orange-600 hover:bg-orange-700 text-white text-sm font-bold py-2 px-4 rounded">
                            Analyze Terrain
                        </button>
                    </div>

                    <div class="mb-3">
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-gray-300">Number of Frames to Analyze</span>
                            <span class="text-orange-300" id="terrain-frames-val">20</span>
                        </div>
                        <input type="range" id="terrain-frames" min="1" max="100" step="5" value="20" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>Faster (1)</span>
                            <span>More thorough (100)</span>
                        </div>
                    </div>

                    <div class="mb-2">
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-gray-300">Filter Strength (std devs)</span>
                            <span class="text-orange-300" id="filter-strength-val">1.5</span>
                        </div>
                        <input type="range" id="filter-strength" min="0.1" max="5.0" step="0.1" value="1.5" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>More detections</span>
                            <span>Less noise</span>
                        </div>
                    </div>

                    <p class="text-xs text-gray-400 mb-3">Analyzes video to learn terrain colors, then filters out detections that match common terrain hues/saturation. Lower = more aggressive filtering.</p>

                    <div id="terrain-info" class="text-xs text-gray-300 bg-gray-800 p-2 rounded hidden"></div>
                </div>

                <!-- Global HSV Distribution Filter -->
                <div class="bg-purple-900 bg-opacity-20 p-4 rounded mb-4 border-2 border-purple-500">
                    <div class="flex items-center justify-between mb-3">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="enable-global-filter" class="w-5 h-5">
                            <span class="text-purple-400 font-semibold">Global Distribution Filter (Exclude Typical Colors)</span>
                        </label>
                        <button id="analyze-global-btn" class="bg-purple-600 hover:bg-purple-700 text-white text-sm font-bold py-2 px-4 rounded">
                            Analyze Video
                        </button>
                    </div>

                    <div class="mb-3">
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-gray-300">Number of Frames to Analyze</span>
                            <span class="text-purple-300" id="global-frames-val">50</span>
                        </div>
                        <input type="range" id="global-frames" min="1" max="100" step="10" value="50" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>Faster (1)</span>
                            <span>More thorough (100)</span>
                        </div>
                    </div>

                    <div class="mb-3">
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-gray-300">Exclusion Threshold (Percentile)</span>
                            <span class="text-purple-300" id="global-threshold-val">90</span>
                        </div>
                        <input type="range" id="global-threshold" min="0" max="100" step="1" value="90" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>None (0%)</span>
                            <span>All (100%)</span>
                        </div>
                    </div>

                    <div class="mb-2">
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-gray-300">Standard Deviations</span>
                            <span class="text-purple-300" id="global-std-val">2.0</span>
                        </div>
                        <input type="range" id="global-std" min="0.1" max="10.0" step="0.1" value="2.0" class="w-full">
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span>Tight (0.1)</span>
                            <span>Wide (10.0)</span>
                        </div>
                    </div>

                    <p class="text-xs text-gray-400 mb-3">Analyzes the entire video's HSV color distribution and excludes detections within typical color ranges. Colors that appear frequently throughout the video are considered "normal" and filtered out.</p>

                    <button id="preview-global-btn" class="bg-purple-500 hover:bg-purple-600 text-white text-sm font-bold py-2 px-4 rounded w-full mb-3">
                        Preview Excluded Colors
                    </button>

                    <div id="global-info" class="text-xs text-gray-300 bg-gray-800 p-2 rounded hidden"></div>
                    <canvas id="global-preview-canvas" class="hidden w-full mt-3 border border-purple-500 rounded"></canvas>
                </div>

                <!-- DBSCAN Settings -->
                <div class="bg-indigo-900 bg-opacity-20 p-4 rounded mb-4 border-2 border-indigo-500">
                    <div class="flex items-center justify-between mb-2">
                        <h3 class="text-lg font-semibold text-indigo-400">DBSCAN Clustering</h3>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="use-dbscan" class="w-5 h-5">
                            <span class="text-indigo-300 font-semibold">Enable DBSCAN Detection</span>
                    </div>
                    <p class="text-xs text-gray-400 mb-3">Uses density-based clustering to identify anomalous color patterns in the video</p>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
                        <div>
                            <div class="flex justify-between text-xs mb-1">
                                <span class="text-gray-300">Epsilon (Color Distance)</span>
                                <span class="text-indigo-300" id="dbscan-eps-val">15</span>
                            </div>
                            <input type="range" id="dbscan-eps" min="5" max="30" step="1" value="15" class="w-full">
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>Tight (5)</span>
                                <span>Loose (30)</span>
                            </div>
                        </div>
                        <div>
                            <div class="flex justify-between text-xs mb-1">
                                <span class="text-gray-300">Min Points per Cluster</span>
                                <span class="text-indigo-300" id="dbscan-minpts-val">5</span>
                            </div>
                            <input type="range" id="dbscan-minpts" min="3" max="20" step="1" value="5" class="w-full">
                            <div class="flex justify-between text-xs text-gray-500 mt-1">
                                <span>Sensitive (3)</span>
                                <span>Robust (20)</span>
                            </div>
                        </div>
                    </div>

                    <div id="dbscan-info" class="text-xs text-gray-300 bg-gray-800 p-2 rounded hidden">
                        <button id="preview-dbscan-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-2 px-4 rounded w-full mb-3">
                        Preview DBSCAN Clusters
                    </button>
                    <canvas id="dbscan-preview-canvas" class="hidden w-full h-48 mt-3 border border-indigo-500 rounded"></canvas>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4">
                    <!-- HSV Controls -->
                    <div id="hsv-controls">
                        <div class="flex items-center space-x-2 mb-3">
                            <input type="checkbox" id="enable-hsv" class="w-5 h-5">
                            <h3 class="text-lg font-medium text-green-400">HSV Color Range</h3>
                        </div>

                        <!-- HSV Option 1 -->
                        <div class="mb-3 p-3 bg-gray-800 border border-green-500 rounded">
                            <div class="flex items-center justify-between mb-2">
                                <label class="flex items-center space-x-2">
                                    <input type="checkbox" id="hsv1-enabled" class="w-4 h-4" checked>
                                    <span class="font-semibold text-green-400">HSV Option 1</span>
                                </label>
                            </div>
                            <div class="flex items-center gap-4 mb-2 text-xs">
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv1-mode" value="include" class="w-3 h-3" checked>
                                    <span class="text-green-300">Include</span>
                                </label>
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv1-mode" value="exclude" class="w-3 h-3">
                                    <span class="text-red-300">Exclude</span>
                                </label>
                            </div>
                            <div class="space-y-2 text-xs">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>H (Hue)</span>
                                        <span><span id="hsv1-h-min-val">0</span> - <span id="hsv1-h-max-val">179</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv1-h-min" min="0" max="179" value="0" class="flex-1">
                                        <input type="range" id="hsv1-h-max" min="0" max="179" value="179" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>S (Saturation)</span>
                                        <span><span id="hsv1-s-min-val">150</span> - <span id="hsv1-s-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv1-s-min" min="0" max="255" value="150" class="flex-1">
                                        <input type="range" id="hsv1-s-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>V (Value)</span>
                                        <span><span id="hsv1-v-min-val">100</span> - <span id="hsv1-v-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv1-v-min" min="0" max="255" value="100" class="flex-1">
                                        <input type="range" id="hsv1-v-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2 bg-gray-900 rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">Color Preview:</div>
                                <canvas id="hsv1-preview" width="200" height="30" class="w-full rounded"></canvas>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between text-xs mb-1">
                                    <span>Size Range (pixels)</span>
                                    <span><span id="hsv1-size-min-val">200</span> - <span id="hsv1-size-max-val">20000</span></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="hsv1-min-size" min="50" max="2000" value="200" class="flex-1">
                                    <input type="range" id="hsv1-max-size" min="2000" max="100000" value="20000" class="flex-1">
                                </div>
                            </div>
                        </div>

                        <!-- HSV Option 2 -->
                        <div class="mb-3 p-3 bg-gray-800 border border-blue-500 rounded">
                            <div class="flex items-center justify-between mb-2">
                                <label class="flex items-center space-x-2">
                                    <input type="checkbox" id="hsv2-enabled" class="w-4 h-4">
                                    <span class="font-semibold text-blue-400">HSV Option 2</span>
                                </label>
                            </div>
                            <div class="flex items-center gap-4 mb-2 text-xs">
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv2-mode" value="include" class="w-3 h-3" checked>
                                    <span class="text-green-300">Include</span>
                                </label>
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv2-mode" value="exclude" class="w-3 h-3">
                                    <span class="text-red-300">Exclude</span>
                                </label>
                            </div>
                            <div class="space-y-2 text-xs">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>H (Hue)</span>
                                        <span><span id="hsv2-h-min-val">0</span> - <span id="hsv2-h-max-val">179</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv2-h-min" min="0" max="179" value="0" class="flex-1">
                                        <input type="range" id="hsv2-h-max" min="0" max="179" value="179" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>S (Saturation)</span>
                                        <span><span id="hsv2-s-min-val">150</span> - <span id="hsv2-s-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv2-s-min" min="0" max="255" value="150" class="flex-1">
                                        <input type="range" id="hsv2-s-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>V (Value)</span>
                                        <span><span id="hsv2-v-min-val">100</span> - <span id="hsv2-v-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv2-v-min" min="0" max="255" value="100" class="flex-1">
                                        <input type="range" id="hsv2-v-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2 bg-gray-900 rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">Color Preview:</div>
                                <canvas id="hsv2-preview" width="200" height="30" class="w-full rounded"></canvas>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between text-xs mb-1">
                                    <span>Size Range (pixels)</span>
                                    <span><span id="hsv2-size-min-val">200</span> - <span id="hsv2-size-max-val">20000</span></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="hsv2-min-size" min="50" max="2000" value="200" class="flex-1">
                                    <input type="range" id="hsv2-max-size" min="2000" max="100000" value="20000" class="flex-1">
                                </div>
                            </div>
                        </div>

                        <!-- HSV Option 3 -->
                        <div class="mb-3 p-3 bg-gray-800 border border-cyan-500 rounded">
                            <div class="flex items-center justify-between mb-2">
                                <label class="flex items-center space-x-2">
                                    <input type="checkbox" id="hsv3-enabled" class="w-4 h-4">
                                    <span class="font-semibold text-cyan-400">HSV Option 3</span>
                                </label>
                            </div>
                            <div class="flex items-center gap-4 mb-2 text-xs">
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv3-mode" value="include" class="w-3 h-3" checked>
                                    <span class="text-green-300">Include</span>
                                </label>
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv3-mode" value="exclude" class="w-3 h-3">
                                    <span class="text-red-300">Exclude</span>
                                </label>
                            </div>
                            <div class="space-y-2 text-xs">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>H (Hue)</span>
                                        <span><span id="hsv3-h-min-val">0</span> - <span id="hsv3-h-max-val">179</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv3-h-min" min="0" max="179" value="0" class="flex-1">
                                        <input type="range" id="hsv3-h-max" min="0" max="179" value="179" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>S (Saturation)</span>
                                        <span><span id="hsv3-s-min-val">150</span> - <span id="hsv3-s-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv3-s-min" min="0" max="255" value="150" class="flex-1">
                                        <input type="range" id="hsv3-s-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>V (Value)</span>
                                        <span><span id="hsv3-v-min-val">100</span> - <span id="hsv3-v-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv3-v-min" min="0" max="255" value="100" class="flex-1">
                                        <input type="range" id="hsv3-v-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2 bg-gray-900 rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">Color Preview:</div>
                                <canvas id="hsv3-preview" width="200" height="30" class="w-full rounded"></canvas>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between text-xs mb-1">
                                    <span>Size Range (pixels)</span>
                                    <span><span id="hsv3-size-min-val">200</span> - <span id="hsv3-size-max-val">20000</span></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="hsv3-min-size" min="50" max="2000" value="200" class="flex-1">
                                    <input type="range" id="hsv3-max-size" min="2000" max="100000" value="20000" class="flex-1">
                                </div>
                            </div>
                        </div>

                        <!-- HSV Option 4 -->
                        <div class="mb-3 p-3 bg-gray-800 border border-red-500 rounded">
                            <div class="flex items-center justify-between mb-2">
                                <label class="flex items-center space-x-2">
                                    <input type="checkbox" id="hsv4-enabled" class="w-4 h-4">
                                    <span class="font-semibold text-red-400">HSV Option 4</span>
                                </label>
                            </div>
                            <div class="flex items-center gap-4 mb-2 text-xs">
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv4-mode" value="include" class="w-3 h-3" checked>
                                    <span class="text-green-300">Include</span>
                                </label>
                                <label class="flex items-center space-x-1 cursor-pointer">
                                    <input type="radio" name="hsv4-mode" value="exclude" class="w-3 h-3">
                                    <span class="text-red-300">Exclude</span>
                                </label>
                            </div>
                            <div class="space-y-2 text-xs">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>H (Hue)</span>
                                        <span><span id="hsv4-h-min-val">0</span> - <span id="hsv4-h-max-val">179</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv4-h-min" min="0" max="179" value="0" class="flex-1">
                                        <input type="range" id="hsv4-h-max" min="0" max="179" value="179" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>S (Saturation)</span>
                                        <span><span id="hsv4-s-min-val">150</span> - <span id="hsv4-s-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv4-s-min" min="0" max="255" value="150" class="flex-1">
                                        <input type="range" id="hsv4-s-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>V (Value)</span>
                                        <span><span id="hsv4-v-min-val">100</span> - <span id="hsv4-v-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="hsv4-v-min" min="0" max="255" value="100" class="flex-1">
                                        <input type="range" id="hsv4-v-max" min="0" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2 bg-gray-900 rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">Color Preview:</div>
                                <canvas id="hsv4-preview" width="200" height="30" class="w-full rounded"></canvas>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between text-xs mb-1">
                                    <span>Size Range (pixels)</span>
                                    <span><span id="hsv4-size-min-val">200</span> - <span id="hsv4-size-max-val">20000</span></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="hsv4-min-size" min="50" max="2000" value="200" class="flex-1">
                                    <input type="range" id="hsv4-max-size" min="2000" max="100000" value="20000" class="flex-1">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Saturation Controls moved from below -->
                    <div id="sat-controls">
                        <div class="flex items-center space-x-2 mb-3">
                            <input type="checkbox" id="enable-sat" class="w-5 h-5">
                            <h3 class="text-lg font-medium text-purple-400">High Saturation</h3>
                        </div>
                        
                        <div class="mb-3 p-3 bg-gray-800 border border-purple-500 rounded">
                            <div class="flex items-center justify-between mb-2">
                                <span class="font-semibold text-purple-400 text-sm">Saturation Detection</span>
                            </div>
                            <div class="space-y-2 text-xs">
                                <div>
                                    <div class="flex justify-between mb-1">
                                        <span>Saturation Range</span>
                                        <span><span id="sat-min-val">200</span> - <span id="sat-max-val">255</span></span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="range" id="sat-min" min="50" max="255" value="200" class="flex-1">
                                        <input type="range" id="sat-max" min="50" max="255" value="255" class="flex-1">
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2 bg-gray-900 rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">Saturation Preview:</div>
                                <canvas id="sat-preview" width="200" height="30" class="w-full rounded"></canvas>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between text-xs mb-1">
                                    <span>Size Range (pixels)</span>
                                    <span><span id="sat-size-min-val">200</span> - <span id="sat-size-max-val">20000</span></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <input type="range" id="sat-min-size" min="50" max="2000" value="200" class="flex-1">
                                    <input type="range" id="sat-max-size" min="2000" max="100000" value="20000" class="flex-1">
                                </div>
                            </div>
                        </div>
                    </div>                    
                </div>

            </div>

            <!-- Color Analysis Section -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6" id="analysis-section">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">Color Analysis</h2>
                    <div class="flex gap-2">
                        <button id="analyze-current-frame-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors">
                            Analyze Current Frame
                        </button>
                        <button id="analyze-whole-video-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors">
                            Analyze Whole Video
                        </button>
                        <button id="use-as-exclusion-btn" class="hidden bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded transition-colors">
                            Use as Exclusion
                        </button>
                    </div>
                </div>
                <div id="analysis-chart-container" class="hidden">
                    <div class="mb-3">
                        <h4 class="text-sm font-medium mb-1">Hue Distribution</h4>
                        <canvas id="color-histogram" width="800" height="300" class="w-full bg-gray-900 rounded"></canvas>
                    </div>
                    <div class="mb-3">
                        <h4 class="text-sm font-medium mb-1">Saturation Distribution</h4>
                        <canvas id="saturation-histogram" width="800" height="300" class="w-full bg-gray-900 rounded"></canvas>
                    </div>
                    <div class="mb-3">
                        <h4 class="text-sm font-medium mb-1">Value Distribution</h4>
                        <canvas id="value-histogram" width="800" height="300" class="w-full bg-gray-900 rounded"></canvas>
                    </div>
                    <div id="analysis-stats" class="mt-3 text-sm grid grid-cols-2 md:grid-cols-4 gap-3"></div>

                </div>
                <p id="analysis-status" class="text-sm text-gray-400">Click a button above to analyze colors</p>
            </div>

            <!-- Batch Processing Section -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6" id="batch-section">
                <h2 class="text-xl font-semibold mb-4">Batch Processing</h2>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                    <div>
                        <label class="text-sm font-medium mb-2 block">Detection Mode</label>
                        <select id="detection-mode" class="w-full bg-gray-700 text-white p-2 rounded">
                            <option value="manual">Manual Settings</option>
                            <option value="smart" selected>Smart Auto-Detect</option>
                        </select>
                    </div>
                    <div>
                        <label class="text-sm font-medium mb-2 block">Sample Every N Frames</label>
                        <input type="number" id="frame-sample-rate" min="1" max="120" value="10" placeholder="e.g., 10" class="w-full bg-gray-700 text-white p-2 rounded border border-gray-600 focus:border-purple-500 focus:outline-none">
                    </div>
                    <div class="col-span-2">
                        <button id="quick-analyze-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors mb-2">
                            Quick Analyze
                        </button>
                        <p class="text-xs text-gray-400 mb-2">Samples video frames to auto-configure optimal detection settings based on color anomalies</p>
                        <button id="batch-process-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded w-full transition-colors">
                            Process All Frames
                        </button>
                    </div>
                </div>

                <!-- Current Settings Indicator -->
                <div id="current-settings-indicator" class="bg-blue-900 border border-blue-500 p-3 rounded mb-4 text-xs">
                    <div class="text-blue-300 font-semibold mb-2">ðŸ“Š Current Detection Settings (will be used for batch):</div>
                    <div class="grid grid-cols-2 gap-2 text-gray-300">
                        <div><strong>HSV Enabled:</strong> <span id="ind-hsv-enabled">Yes</span></div>
                        <div><strong>Sat Enabled:</strong> <span id="ind-sat-enabled">No</span></div>
                        <div><strong>Hue Range:</strong> <span id="ind-hue-range">100-130</span></div>
                        <div><strong>Sat Range:</strong> <span id="ind-sat-range">150-255</span></div>
                        <div><strong>Smart Filter:</strong> <span id="ind-smart-filter">Off</span></div>
                        <div><strong>Global Filter:</strong> <span id="ind-global-filter">Off</span></div>
                        <div><strong>Size Range:</strong> <span id="ind-size-range">200-20000px</span></div>
                        <div><strong>Exclusion Source:</strong> <span id="ind-exclusion-source">None</span></div>
                        <div><strong>DBSCAN:</strong> <span id="ind-dbscan">Off</span></div>
                    </div>
                </div>

                <div id="smart-settings-info" class="hidden bg-gray-700 p-3 rounded mb-4 text-xs">
                    <div class="text-orange-400 font-semibold mb-1">Smart Detection Settings:</div>
                    <div id="smart-settings-text" class="text-gray-300"></div>
                </div>
                <div id="batch-progress" class="hidden mb-3">
                    <div class="w-full bg-gray-700 rounded-full h-4">
                        <div id="batch-progress-bar" class="bg-purple-600 h-4 rounded-full transition-all" style="width: 0%"></div>
                    </div>
                    <p id="batch-progress-text" class="text-xs text-gray-400 mt-1">Processing...</p>
                </div>
                <div id="detection-list-container" class="hidden">
                    <h3 class="text-lg font-semibold mb-2">Detection Results</h3>
                    <div id="detection-list" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 max-h-[600px] overflow-y-auto bg-gray-900 rounded p-3"></div>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="hidden">
                    <video id="video-in" controls></video>
                </div>

                <div class="bg-gray-800 p-4 rounded-lg shadow-lg col-span-1 md:col-span-2">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold">Processed Output</h2>
                        <button id="start-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-200">
                            â–¶ Start
                        </button>
                    </div>
                    <p id="status-msg" class="text-sky-400 mb-2 text-sm">Status: Waiting for video file...</p>
                    <p class="text-xs text-gray-400 mb-2">Click image to view fullscreen</p>
                    <div class="aspect-video bg-gray-900 rounded overflow-hidden relative">
                        <canvas id="canvas-out" style="width: 100%; height: 100%; object-fit: contain; cursor: pointer;"></canvas>
                    </div>

                    <!-- Detection Details Below Output -->
                    <div id="current-frame-detections" class="mt-3 p-3 bg-gray-700 rounded hidden">
                        <h3 class="text-sm font-semibold text-sky-400 mb-2">Current Frame Detections:</h3>
                        <div id="current-detections-list" class="space-y-1 text-xs max-h-40 overflow-y-auto"></div>
                    </div>

                    <div class="mt-4">
                        <input type="range" id="video-seek" min="0" max="100" value="0" class="w-full">
                    </div>
                </div>
            </div>

        </main>
    </div>

 <script>
        let video;
        let videoStream;
        let cap;
        let srcMat, rgbMat, hsvMat, maskMat, contours, hierarchy;
        let isProcessing = false;
        let dbscanAnomalyTargets = [];
        let fps = 30;
        let elapsed;
        let then;
        let now;

        // Terrain baseline for smart filtering
        let terrainBaseline = null;
        let useSmartFilter = false;
        
        // Global HSV distribution for whole video
        let globalHsvDistribution = null;
        let enableGlobalFilter = false;
        
        let isSeekingSuppressed = false;
        let isProgrammaticChange = false; // Flag to prevent cascading processSingleFrame calls

        // Batch processing state
        let batchDetections = [];
        let colorAnalysisData = null;
        let activePresetButton = null;
        let excludedColorRanges = []; // Array of {min, max} hue ranges to exclude
        
        // --- NEW ---
        let dbscanPreviewData = null; // Holds data for the cluster preview

        function initMatsIfReady() {
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                const canvas = document.getElementById('canvas-out');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                video.width = video.videoWidth;
                video.height = video.videoHeight;

                if (srcMat) {
                    srcMat.delete();
                    rgbMat.delete();
                    hsvMat.delete();
                    maskMat.delete();
                    if (contours) {
                        for (let i = 0; i < contours.size(); ++i) {
                            contours.get(i).delete();
                        }
                        contours.delete();
                    }
                    hierarchy.delete();
                }

                srcMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
                rgbMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
                hsvMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
                maskMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
                contours = new cv.MatVector();
                hierarchy = new cv.Mat();

                cap = new cv.VideoCapture(video);

                cap.read(srcMat);
                cv.imshow('canvas-out', srcMat);

                updateStatus("Ready to process. Press Start.", "text-green-400");
            }
        }

        function onOpenCvReady() {
            console.log("OpenCV.js is ready.");
            document.getElementById('loader').classList.add('hidden');
            document.getElementById('app-content').classList.remove('hidden');
            
            video = document.getElementById('video-in');
            
            document.getElementById('video-input').addEventListener('change', (e) => {
                if (isProcessing) {
                    pauseProcessing();
                }
                
                // Clean up old resources
                if (cap) {
                    cap.delete();
                    cap = null;
                }
                if (srcMat) {
                    srcMat.delete();
                    rgbMat.delete();
                    hsvMat.delete();
                    maskMat.delete();
                    if (contours) {
                        for (let i = 0; i < contours.size(); ++i) {
                            contours.get(i).delete();
                        }
                        contours.delete();
                    }
                    hierarchy.delete();
                }
                
                // Reset terrain baseline
                terrainBaseline = null;
                useSmartFilter = false;
                document.getElementById('enable-smart-filter').checked = false;
                document.getElementById('terrain-info').classList.add('hidden');
                
                const file = e.target.files[0];
                if (!file) return;

                updateStatus("Loading video...", "text-blue-400");

                const url = URL.createObjectURL(file);
                video.src = url;
                video.loop = true;
                video.muted = true; // Required for autoplay on mobile
                video.playsInline = true; // Required for iOS

                video.onloadedmetadata = () => {
                    updateStatus("Video loaded! Initializing OpenCV...", "text-green-400");

                    // Display video information
                    const duration = video.duration;
                    const fps = 30; // Estimate, could be refined
                    const totalFrames = Math.floor(duration * fps);

                    document.getElementById('video-duration').textContent = `${duration.toFixed(2)}s`;
                    document.getElementById('video-frames').textContent = totalFrames.toString();
                    document.getElementById('video-fps').textContent = `~${fps}`;
                    document.getElementById('video-info').classList.remove('hidden');

                    initMatsIfReady();
                };

                video.onerror = (err) => {
                    console.error("Video load error:", err);
                    updateStatus("Error loading video. Try a different format (MP4 recommended).", "text-red-400");
                };

                video.load();
            });

            document.getElementById('start-btn').addEventListener('click', () => {
                if (!video.src) {
                    updateStatus("Please load a video file first.", "text-red-400");
                    return;
                }
                
                if (isProcessing) {
                    pauseProcessing();
                } else {
                    startProcessing();
                }
            });
            
            document.getElementById('analyze-terrain-btn').addEventListener('click', () => {
                if (!video.src) {
                    updateStatus("Please load a video first.", "text-red-400");
                    return;
                }
                analyzeTerrain();
            });
            
            document.getElementById('enable-smart-filter').addEventListener('change', (e) => {
                useSmartFilter = e.target.checked;
                if (useSmartFilter && !terrainBaseline) {
                    alert('Please click "Analyze Terrain" first to build the baseline.');
                    e.target.checked = false;
                    useSmartFilter = false;
                } else if (terrainBaseline) {
                    // Update terrain info display when checkbox is toggled
                    const terrainFrames = document.getElementById('terrain-frames').value;
                    const filterStrength = document.getElementById('filter-strength').value;
                    const infoEl = document.getElementById('terrain-info');
                    const currentHTML = infoEl.innerHTML;

                    // Update the active/inactive status in the existing HTML
                    const updatedHTML = currentHTML.replace(
                        /class="[^"]*">[^<]*(?:âœ“ ACTIVE|â—‹ INACTIVE)/,
                        `class="${useSmartFilter ? 'text-orange-400' : 'text-gray-400'}">${useSmartFilter ? 'âœ“ ACTIVE' : 'â—‹ INACTIVE'}`
                    ).replace(
                        /To (?:disable|enable): (?:uncheck|check)/,
                        `To ${useSmartFilter ? 'disable' : 'enable'}: ${useSmartFilter ? 'uncheck' : 'check'}`
                    );

                    infoEl.innerHTML = updatedHTML;
                }
            });
            
            // Global HSV distribution filter event listeners
            document.getElementById('analyze-global-btn').addEventListener('click', () => {
                if (!video || !video.src) {
                    updateStatus("Please load a video first.", "text-red-400");
                    return;
                }
                analyzeGlobalDistribution();
            });
            
            document.getElementById('enable-global-filter').addEventListener('change', (e) => {
                enableGlobalFilter = e.target.checked;
                if (enableGlobalFilter && !globalHsvDistribution) {
                    alert('Please click "Analyze Video" first to build the global distribution.');
                    e.target.checked = false;
                    enableGlobalFilter = false;
                } else if (globalHsvDistribution) {
                    const infoEl = document.getElementById('global-info');
                    const currentHTML = infoEl.innerHTML;
                    const updatedHTML = currentHTML.replace(
                        /class="[^"]*">[^<]*(?:âœ“ ACTIVE|â—‹ INACTIVE)/,
                        `class="${enableGlobalFilter ? 'text-purple-400' : 'text-gray-400'}">${enableGlobalFilter ? 'âœ“ ACTIVE' : 'â—‹ INACTIVE'}`
                    ).replace(
                        /To (?:disable|enable): (?:uncheck|check)/,
                        `To ${enableGlobalFilter ? 'disable' : 'enable'}: ${enableGlobalFilter ? 'uncheck' : 'check'}`
                    );
                    infoEl.innerHTML = updatedHTML;
                }
            });
            
            document.getElementById('global-frames').addEventListener('input', (e) => {
                document.getElementById('global-frames-val').textContent = e.target.value;
            });
            
            document.getElementById('global-threshold').addEventListener('input', (e) => {
                document.getElementById('global-threshold-val').textContent = e.target.value;
            });
            
            document.getElementById('global-std').addEventListener('input', (e) => {
                document.getElementById('global-std-val').textContent = e.target.value;
                if (globalHsvDistribution) updateGlobalPreview();
            });
            
            document.getElementById('global-threshold').addEventListener('input', (e) => {
                document.getElementById('global-threshold-val').textContent = e.target.value;
                if (globalHsvDistribution) updateGlobalPreview();
            });
            
            document.getElementById('preview-global-btn').addEventListener('click', () => {
                if (!globalHsvDistribution) {
                    alert('Please run "Analyze Video" first to build the distribution.');
                    return;
                }
                updateGlobalPreview();
            });

            // --- NEW ---
            // Add listener for the new DBSCAN preview button
            const previewDbscanBtn = document.getElementById('preview-dbscan-btn');
            if (previewDbscanBtn) {
                previewDbscanBtn.addEventListener('click', drawDbscanPreview);
            }
            // --- END NEW ---
            
            // Simple modal like Python script
            const canvas = document.getElementById('canvas-out');
            const modal = document.getElementById('canvas-modal');
            const modalCanvas = document.getElementById('modal-canvas');
            const closeBtn = document.getElementById('close-modal');

            canvas.addEventListener('click', () => {
                modalCanvas.width = canvas.width;
                modalCanvas.height = canvas.height;
                const ctx = modalCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, 0);
                modal.classList.remove('hidden');
            });

            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
                document.getElementById('modal-prev').classList.add('hidden');
                document.getElementById('modal-next').classList.add('hidden');
                document.getElementById('modal-info').classList.add('hidden');
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                    document.getElementById('modal-prev').classList.add('hidden');
                    document.getElementById('modal-next').classList.add('hidden');
                    document.getElementById('modal-info').classList.add('hidden');
                }
            });

            // Modal navigation buttons
            document.getElementById('modal-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                navigateModal(-1);
            });

            document.getElementById('modal-next').addEventListener('click', (e) => {
                e.stopPropagation();
                navigateModal(1);
            });

            // Keyboard navigation for modal
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('canvas-modal');
                if (!modal.classList.contains('hidden')) {
                    if (e.key === 'ArrowLeft') {
                        navigateModal(-1);
                    } else if (e.key === 'ArrowRight') {
                        navigateModal(1);
                    } else if (e.key === 'Escape') {
                        modal.classList.add('hidden');
                        document.getElementById('modal-prev').classList.add('hidden');
                        document.getElementById('modal-next').classList.add('hidden');
                        document.getElementById('modal-info').classList.add('hidden');
                    }
                }
            });

            const sliders = [
                'hsv1-min-size', 'hsv1-max-size',
                'hsv2-min-size', 'hsv2-max-size',
                'hsv3-min-size', 'hsv3-max-size',
                'sat-min', 'sat-max', 'sat-min-size', 'sat-max-size'
            ];
            sliders.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        let valId = id + '-val';
                        if (id === 'hsv1-min-size') valId = 'hsv1-size-min-val';
                        if (id === 'hsv1-max-size') valId = 'hsv1-size-max-val';
                        if (id === 'hsv2-min-size') valId = 'hsv2-size-min-val';
                        if (id === 'hsv2-max-size') valId = 'hsv2-size-max-val';
                        if (id === 'hsv3-min-size') valId = 'hsv3-size-min-val';
                        if (id === 'hsv3-max-size') valId = 'hsv3-size-max-val';
                        if (id === 'sat-min-size') valId = 'sat-size-min-val';
                        if (id === 'sat-max-size') valId = 'sat-size-max-val';

                    if(document.getElementById(valId)) {
                        document.getElementById(valId).textContent = e.target.value;
                    }


                    if (!isProcessing && !isProgrammaticChange) {
                        processSingleFrame();
                    }
                    });
                }
            });

            // Filter strength slider - update display only, don't reprocess
            document.getElementById('filter-strength').addEventListener('input', (e) => {
                document.getElementById('filter-strength-val').textContent = e.target.value;
            });

            document.getElementById('terrain-frames').addEventListener('input', (e) => {
                document.getElementById('terrain-frames-val').textContent = e.target.value;
            });

            document.getElementById('dbscan-eps').addEventListener('input', (e) => {
                document.getElementById('dbscan-eps-val').textContent = e.target.value;
            });

            document.getElementById('dbscan-minpts').addEventListener('input', (e) => {
                document.getElementById('dbscan-minpts-val').textContent = e.target.value;
            });

            // Color preset buttons with toggle
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    // Toggle: if clicking the same button, deselect it
                    if (activePresetButton === btn) {
                        // Deselect
                        btn.classList.remove('ring-2', 'ring-white');
                        activePresetButton = null;
                        updateColorPreviews();
                        updateSettingsIndicator();
                        if (!isProcessing) {
                            processSingleFrame();
                        }
                        return;
                    }

                    // Deselect previous button
                    if (activePresetButton) {
                        activePresetButton.classList.remove('ring-2', 'ring-white');
                    }

                    // Select new button
                    activePresetButton = btn;
                    btn.classList.add('ring-2', 'ring-white');

                    const hueMin = parseInt(btn.dataset.hueMin);
                    const hueMax = parseInt(btn.dataset.hueMax);

                    // Set flag to prevent cascading processSingleFrame calls
                    isProgrammaticChange = true;

                    // Update HSV Option 1 with preset values
                    document.getElementById('hsv1-h-min').value = hueMin;
                    document.getElementById('hsv1-h-max').value = hueMax;
                    document.getElementById('hsv1-s-min').value = 150;
                    document.getElementById('hsv1-s-max').value = 255;
                    document.getElementById('hsv1-v-min').value = 100;
                    document.getElementById('hsv1-v-max').value = 255;
                    document.getElementById('enable-hsv').checked = true;
                    document.getElementById('hsv1-enabled').checked = true;

                    // Clear flag
                    isProgrammaticChange = false;

                    updateColorPreviews();
                    updateSettingsIndicator();
                    if (!isProcessing) {
                        processSingleFrame();
                    }
                });
            });

            // Color preview canvases
            updateColorPreviews();
            ['sat-min', 'sat-max'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', (e) => {
                        // Update value display
                        const valEl = document.getElementById(`${id}-val`);
                        if (valEl) {
                            valEl.textContent = e.target.value;
                        }
                        
                        // Update preview
                        updateSaturationPreview();
                        
                        // Reprocess if not processing
                        if (!isProcessing && !isProgrammaticChange) {
                            processSingleFrame();
                        }
                    });
                }
            });            
            // ['sat-min', 'sat-max'].forEach(id => {
            //     const el = document.getElementById(id);
            //     if (el) el.addEventListener('input', updateColorPreviews);
            // });

            // Add event listeners for HSV option inputs (1, 2, 3, 4)
            const hsvOptionInputs = [
                { ids: ['hsv1-h-min', 'hsv1-h-max', 'hsv1-s-min', 'hsv1-s-max', 'hsv1-v-min', 'hsv1-v-max'], prefix: 'hsv1' },
                { ids: ['hsv2-h-min', 'hsv2-h-max', 'hsv2-s-min', 'hsv2-s-max', 'hsv2-v-min', 'hsv2-v-max'], prefix: 'hsv2' },
                { ids: ['hsv3-h-min', 'hsv3-h-max', 'hsv3-s-min', 'hsv3-s-max', 'hsv3-v-min', 'hsv3-v-max'], prefix: 'hsv3' },
                { ids: ['hsv4-h-min', 'hsv4-h-max', 'hsv4-s-min', 'hsv4-s-max', 'hsv4-v-min', 'hsv4-v-max'], prefix: 'hsv4' }
            ];

            hsvOptionInputs.forEach(option => {
                option.ids.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('input', () => {
                            // Update value display
                            const valEl = document.getElementById(`${id}-val`);
                            if (valEl) {
                                valEl.textContent = el.value;
                            }

                            // Only update this option's preview
                            updateHSVPreview(option.prefix);
                            if (!isProcessing && !isProgrammaticChange) {
                                processSingleFrame();
                            }
                        });
                    }
                });
            });

            // Batch processing button
            document.getElementById('batch-process-btn').addEventListener('click', batchProcessVideo);

            // Quick analyze button
            document.getElementById('quick-analyze-btn').addEventListener('click', quickAnalyzeAndConfigure);

            // Analysis buttons
            document.getElementById('analyze-current-frame-btn').addEventListener('click', analyzeCurrentFrame);
            document.getElementById('analyze-whole-video-btn').addEventListener('click', analyzeWholeVideo);
            document.getElementById('use-as-exclusion-btn').addEventListener('click', useAnalysisAsExclusion);

            // Color exclusion checkboxes
            document.querySelectorAll('.exclude-color-check').forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    // Update excluded ranges
                    excludedColorRanges = [];
                    document.querySelectorAll('.exclude-color-check:checked').forEach(cb => {
                        excludedColorRanges.push({
                            min: parseInt(cb.dataset.hueMin),
                            max: parseInt(cb.dataset.hueMax)
                        });
                    });
                    console.log('Excluded color ranges:', excludedColorRanges);

                    // Reprocess current frame
                    if (!isProcessing) {
                        processSingleFrame();
                    }
                });
            });

            // Update settings indicator whenever settings change
            document.getElementById('enable-hsv').addEventListener('change', updateSettingsIndicator);
            document.getElementById('enable-sat').addEventListener('change', updateSettingsIndicator);
            document.getElementById('enable-smart-filter').addEventListener('change', updateSettingsIndicator);
            document.getElementById('enable-global-filter').addEventListener('change', updateSettingsIndicator);
            ['hsv-min-size', 'hsv-max-size'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateSettingsIndicator);
            });
            updateSettingsIndicator(); // Initial update

            // Detection mode change listener
            document.getElementById('detection-mode').addEventListener('change', () => {
                updateSettingsIndicator();
                const mode = document.getElementById('detection-mode').value;
                if (mode === 'smart') {
                    updateStatus("Smart mode selected. Click 'Quick Analyze' to auto-configure settings.", "text-indigo-400");
                } else {
                    updateStatus("Manual mode selected. Adjust settings manually or use preset buttons.", "text-blue-400");
                }
            });

            // Video seek slider
            document.getElementById('video-seek').addEventListener('input', (e) => {
                if (!video || !video.duration || isSeekingSuppressed) return;

                const seekPercent = parseFloat(e.target.value);
                const seekTime = (seekPercent / 100) * video.duration;
                video.currentTime = seekTime;

                if (!isProcessing) {
                    const onSeekedHandler = () => {
                        video.removeEventListener('seeked', onSeekedHandler);
                        processSingleFrame();
                    };
                    video.addEventListener('seeked', onSeekedHandler, { once: true });
                }
            });

            // Update slider when video time changes
            video.addEventListener('timeupdate', () => {
                if (!isSeekingSuppressed && video.duration) {
                    const percent = (video.currentTime / video.duration) * 100;
                    document.getElementById('video-seek').value = percent;
                }
            });
        }

        function quickAnalyzeAndConfigure() {
            if (!video || !video.videoWidth) {
                alert('Please load a video first');
                return;
            }

            if (isProcessing) {
                alert('Please pause video processing first');
                return;
            }

            const useDbscan = document.getElementById('use-dbscan').checked;
            updateStatus("Quick analyzing video for smart detection...", "text-indigo-400");

            // First analyze terrain if not done
            if (!terrainBaseline) {
                analyzeTerrain();
                // Wait for terrain analysis to complete, then continue
                const checkInterval = setInterval(() => {
                    if (terrainBaseline) {
                        clearInterval(checkInterval);
                        if (useDbscan) {
                            performDbscanAnalysis();
                        } else {
                            performSmartAnalysis();
                        }
                    }
                }, 500);
            } else {
                if (useDbscan) {
                    performDbscanAnalysis();
                } else {
                    performSmartAnalysis();
                }
            }
        }

        function performSmartAnalysis() {
            const savedTime = video.currentTime;
            isSeekingSuppressed = true;

            // Mark that DBSCAN was NOT used
            window.dbscanUsed = false;

            const duration = video.duration;
            const sampleFrames = 20;
            const frameStep = duration / sampleFrames;

            let allHues = {};
            let allSats = [];
            let frameIndex = 0;

            function sampleNext() {
                if (frameIndex >= sampleFrames) {
                    isSeekingSuppressed = false;
                    video.currentTime = savedTime;

                    // Calculate smart detection parameters
                    configureSmartDetection(allHues, allSats);
                    return;
                }

                const onSeekedHandler = () => {
                    video.removeEventListener('seeked', onSeekedHandler);

                    try {
                        cap.read(srcMat);
                        cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                        const h = hsvMat.rows;
                        const w = hsvMat.cols;
                        const step = 30;

                        for (let y = 0; y < h; y += step) {
                            for (let x = 0; x < w; x += step) {
                                const hue = hsvMat.ucharPtr(y, x)[0];
                                const sat = hsvMat.ucharPtr(y, x)[1];
                                const val = hsvMat.ucharPtr(y, x)[2];

                                // --- FIX ---
                                // Only analyze pixels that are somewhat saturated (not grey/brown)
                                // and not too dark/bright
                                if (val > 40 && val < 240 && sat > 40) {
                                // --- END FIX ---
                                    allHues[hue] = (allHues[hue] || 0) + 1;
                                    allSats.push(sat);
                                }
                            }
                        }

                        frameIndex++;
                        setTimeout(sampleNext, 50);
                    } catch (err) {
                        console.error("Error:", err);
                        isSeekingSuppressed = false;
                        video.currentTime = savedTime;
                    }
                };

                video.addEventListener('seeked', onSeekedHandler, { once: true });
                video.currentTime = Math.min(frameIndex * frameStep, duration - 0.1);
            }

            sampleNext();
        }

        function performDbscanAnalysis() {
                    const savedTime = video.currentTime;
                    isSeekingSuppressed = true;

                    // Mark that DBSCAN was used
                    window.dbscanUsed = true;
                    // --- NEW ---
                    dbscanPreviewData = null; // Clear old preview data
                    document.getElementById('dbscan-preview-canvas').classList.add('hidden'); // Hide old preview
                    // --- END NEW ---

                    const duration = video.duration;
                    const sampleFrames = 10; // 10 frames is fine
                    const frameStep = duration / sampleFrames;

                    let allPixels = [];
                    let frameIndex = 0;

                    function sampleNext() {
                        if (frameIndex >= sampleFrames) {
                            isSeekingSuppressed = false;
                            video.currentTime = savedTime;

                            // Limit pixel count for DBSCAN performance
                            // *** FIX: Increased pixel limit for better sampling ***
                            const maxPixels = 5000; // Was 500
                            if (allPixels.length > maxPixels) {
                                // Randomly sample pixels
                                allPixels = allPixels.sort(() => 0.5 - Math.random()).slice(0, maxPixels);
                            }
                            
                            if (allPixels.length < 50) {
                                updateStatus(`DBSCAN Error: Not enough vivid pixels found to analyze. Try lowering S/V in HSV Options.`, "text-red-400");
                                isSeekingSuppressed = false;
                                video.currentTime = savedTime;
                                return;
                            }

                            updateStatus(`Running DBSCAN on ${allPixels.length} pixels...`, "text-indigo-400");

                            // Get DBSCAN parameters from sliders
                            const eps = parseInt(document.getElementById('dbscan-eps').value) || 15;
                            const minPts = parseInt(document.getElementById('dbscan-minpts').value) || 5;

                            // Perform DBSCAN clustering
                            const clusters = dbscan(allPixels, eps, minPts);
                            
                            // --- NEW ---
                            // Save data for preview
                            dbscanPreviewData = { pixels: allPixels, labels: clusters.labels, numClusters: clusters.numClusters };
                            // --- END NEW ---
                            
                            configureDbscanDetection(clusters, allPixels);
                            return;
                        }

                        const onSeekedHandler = () => {
                            video.removeEventListener('seeked', onSeekedHandler);

                            try {
                                cap.read(srcMat);
                                cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                                const h = hsvMat.rows;
                                const w = hsvMat.cols;
                                
                                // *** FIX: Denser sampling step ***
                                const step = 30; // Was 50

                                for (let y = 0; y < h; y += step) {
                                    for (let x = 0; x < w; x += step) {
                                        const hue = hsvMat.ucharPtr(y, x)[0];
                                        const sat = hsvMat.ucharPtr(y, x)[1];
                                        const val = hsvMat.ucharPtr(y, x)[2];

                                        // *** FIX: Stronger filter to find VIVID anomalies ***
                                        // Only sample pixels that are not dull
                                        if (val > 50 && val < 240 && sat > 70) { // Was val>30, val<230, sat>50
                                            allPixels.push({hue, sat, val});
                                        }
                                    }
                                }

                                frameIndex++;
                                setTimeout(sampleNext, 50);
                            } catch (err) {
                                console.error("Error:", err);
                                isSeekingSuppressed = false;
                                video.currentTime = savedTime;
                            }
                        };

                        video.addEventListener('seeked', onSeekedHandler, { once: true });
                        video.currentTime = Math.min(frameIndex * frameStep, duration - 0.1);
                    }

                    sampleNext();
                }

        function dbscan(points, eps, minPts) {
            const labels = new Array(points.length).fill(-1);
            let clusterId = 0;

            function distance(p1, p2) {
                // Euclidean distance in HSV space
                const dh = Math.min(Math.abs(p1.hue - p2.hue), 180 - Math.abs(p1.hue - p2.hue));
                const ds = Math.abs(p1.sat - p2.sat);
                return Math.sqrt(dh * dh + ds * ds);
            }

            function regionQuery(pointIdx) {
                const neighbors = [];
                for (let i = 0; i < points.length; i++) {
                    if (distance(points[pointIdx], points[i]) <= eps) {
                        neighbors.push(i);
                    }
                }
                return neighbors;
            }

            function expandCluster(pointIdx, neighbors, clusterId) {
                labels[pointIdx] = clusterId;
                const neighborSet = new Set(neighbors);

                for (let i = 0; i < neighbors.length; i++) {
                    const neighborIdx = neighbors[i];

                    if (labels[neighborIdx] === -1 || labels[neighborIdx] === undefined) {
                        labels[neighborIdx] = clusterId;
                        const neighborNeighbors = regionQuery(neighborIdx);
                        if (neighborNeighbors.length >= minPts) {
                            // Add new neighbors using Set to avoid duplicates
                            for (const nn of neighborNeighbors) {
                                if (!neighborSet.has(nn)) {
                                    neighbors.push(nn);
                                    neighborSet.add(nn);
                                }
                            }
                        }
                    }
                }
            }

            for (let i = 0; i < points.length; i++) {
                if (labels[i] !== -1) continue;

                const neighbors = regionQuery(i);
                if (neighbors.length < minPts) {
                    labels[i] = -1; // Noise
                } else {
                    expandCluster(i, neighbors, clusterId);
                    clusterId++;
                }
            }

            return { labels, numClusters: clusterId };
        }

        // --- REVERTED/FIXED FUNCTION ---
        function configureDbscanDetection(clusters, pixels) {
            // Find anomalous clusters (smaller clusters are likely anomalies)
            const clusterSizes = {};
            clusters.labels.forEach(label => {
                if (label !== -1) {
                    clusterSizes[label] = (clusterSizes[label] || 0) + 1;
                }
            });

            // Get cluster statistics
            const clusterStats = {};
            clusters.labels.forEach((label, idx) => {
                if (label !== -1) {
                    if (!clusterStats[label]) {
                        clusterStats[label] = { hues: [], sats: [], vals: [] };
                    }
                    clusterStats[label].hues.push(pixels[idx].hue);
                    clusterStats[label].sats.push(pixels[idx].sat);
                    clusterStats[label].vals.push(pixels[idx].val);
                }
            });

            // Find smallest clusters (anomalies)
            // --- FIX: Sort by SMALLEST first (a[1] - b[1]) ---
            const sortedClusters = Object.entries(clusterSizes).sort((a, b) => a[1] - b[1]);
            
            // Clear previous targets
            dbscanAnomalyTargets = [];
            
            if (sortedClusters.length === 0) {
                updateStatus("No distinct color clusters found.", "text-yellow-400");
                document.getElementById('dbscan-info').classList.remove('hidden');
                document.getElementById('dbscan-info').innerHTML = `<strong class="text-red-400">âœ— DBSCAN Analysis Failed</strong><br>No clusters found.`;
                return;
            }

            // Get DBSCAN parameters from sliders
            const eps = parseInt(document.getElementById('dbscan-eps').value) || 15;
            // Use HSV1's size as a default for the new targets
            const minSize = parseInt(document.getElementById('hsv1-min-size').value) || 200;
            const maxSize = parseInt(document.getElementById('hsv1-max-size').value) || 20000;

            // Use the smallest 3 clusters as the anomaly targets
            const numTargets = Math.min(sortedClusters.length, 3);
            let infoHtml = `<strong class="text-indigo-400">âœ“ DBSCAN Analysis Complete</strong><br>Found ${clusters.numClusters} clusters. Targeting ${numTargets} smallest (anomalies):<div class="pl-2 mt-1">`;

            for (let i = 0; i < numTargets; i++) {
                // --- FIX: Take from the start of the list (smallest) ---
                const anomalyClusterId = sortedClusters[i][0];
                const stats = clusterStats[anomalyClusterId];

                const avgHue = stats.hues.reduce((a, b) => a + b, 0) / stats.hues.length;
                const avgSat = stats.sats.reduce((a, b) => a + b, 0) / stats.sats.length;
                const avgVal = stats.vals.reduce((a, b) => a + b, 0) / stats.vals.length;

                // Configure HSV ranges around the anomaly cluster
                const hueRange = eps; // Use Epsilon as the range
                const satRange = eps * 1.5; // Sat range can be a bit wider
                const valRange = 40; // Value range

                const target = {
                    hMin: Math.max(0, Math.floor(avgHue - hueRange)),
                    hMax: Math.min(179, Math.ceil(avgHue + hueRange)),
                    sMin: Math.max(0, Math.floor(avgSat - satRange)),
                    sMax: Math.min(255, Math.ceil(avgSat + satRange)),
                    vMin: Math.max(50, Math.floor(avgVal - valRange)), // Ignore dark values
                    vMax: Math.min(255, Math.ceil(avgVal + valRange)),
                    minSize: minSize,
                    maxSize: maxSize,
                    label: `DBSCAN ${i+1} (H:${avgHue.toFixed(0)}, S:${avgSat.toFixed(0)})`
                };
                
                // Handle Hue wraparound for red
                if (avgHue < hueRange) { // e.g., avgHue 5, eps 15 -> 0-20
                    target.hMin = 0;
                    target.hMax = Math.ceil(avgHue + hueRange);
                    // Add the other side of red
                    dbscanAnomalyTargets.push({ ...target, hMin: Math.floor(179 - (hueRange - avgHue)), hMax: 179, label: target.label + " (wrap)" });
                } else if (avgHue > (179 - hueRange)) { // e.g., avgHue 175, eps 15 -> 160-179
                    target.hMin = Math.floor(avgHue - hueRange);
                    target.hMax = 179;
                    // Add the other side of red
                    dbscanAnomalyTargets.push({ ...target, hMin: 0, hMax: Math.ceil((hueRange - (179 - avgHue))), label: target.label + " (wrap)" });
                }
                
                dbscanAnomalyTargets.push(target);

                infoHtml += `<strong>â€¢ Target ${i+1}:</strong> H:${target.hMin}-${target.hMax}, S:${target.sMin}-${target.sMax}<br>`;
            }

            infoHtml += `</div><em class="text-indigo-300">Detection enabled. Toggle "Enable DBSCAN Detection" checkbox to use.</em>`;

            // Show DBSCAN info
            document.getElementById('dbscan-info').classList.remove('hidden');
            document.getElementById('dbscan-info').innerHTML = infoHtml;

            // DO NOT set HSV sliders
            
            updateStatus(`DBSCAN: Configured ${numTargets} anomaly targets. Enable checkbox to use.`, "text-green-400");
            
            // Enable the checkbox for the user
            document.getElementById('use-dbscan').checked = true;

            // Update settings indicator and reprocess current frame
            updateSettingsIndicator();
            if (!isProcessing && video && video.videoWidth) {
                processSingleFrame();
            }
        }
        // --- END REVERTED/FIXED FUNCTION ---

        function configureSmartDetection(hueData, satData) {
            // Find outlier hues (statistical anomalies)
            const totalHueCount = Object.values(hueData).reduce((a, b) => a + b, 0);
            const avgHueCount = totalHueCount / 180;
            const hueStdDev = Math.sqrt(
                Object.values(hueData).reduce((sum, count) => sum + Math.pow((count || 0) - avgHueCount, 2), 0) / 180
            );

            console.log("=== SMART DETECTION ANALYSIS ===");
            console.log(`Total hue count: ${totalHueCount}, Average per hue: ${avgHueCount.toFixed(1)}, Std Dev: ${hueStdDev.toFixed(1)}`);
            if (terrainBaseline) {
                console.log(`Terrain baseline - Hue: ${terrainBaseline.hueMean.toFixed(1)} Â± ${terrainBaseline.hueStd.toFixed(1)}, Sat: ${terrainBaseline.satMean.toFixed(1)} Â± ${terrainBaseline.satStd.toFixed(1)}`);
            }

            // Find hues that are significantly above average (potential targets)
            const significantHues = [];
            for (let h = 0; h < 180; h++) {
                const count = hueData[h] || 0;
                const zScore = (count - avgHueCount) / hueStdDev;

                // If this hue is rare (below average) but when it appears, it's significant
                // OR if terrain baseline exists, find hues outside terrain range
                if (terrainBaseline) {
                    // Special handling for red hue wraparound (reds are 0-15 and 165-179)
                    let hueDiff;
                    if (h <= 15 || h >= 165) {
                        // Red zone - calculate circular distance
                        const redCenter = 0; // or 179
                        if (h <= 15) {
                            hueDiff = Math.min(Math.abs(h - terrainBaseline.hueMean),
                                             Math.abs((h + 180) - terrainBaseline.hueMean));
                        } else {
                            hueDiff = Math.min(Math.abs(h - terrainBaseline.hueMean),
                                             Math.abs((h - 180) - terrainBaseline.hueMean));
                        }
                    } else {
                        hueDiff = Math.abs(h - terrainBaseline.hueMean);
                    }

                    const hueSigma = hueDiff / terrainBaseline.hueStd;

                    // VERY AGGRESSIVE: 1.0 std dev and only 1% frequency (was 1.5 and 3%)
                    if (hueSigma > 1.0 && count > avgHueCount * 0.01) {
                        significantHues.push({ hue: h, score: hueSigma, count: count });
                        console.log(`  Anomaly found at hue ${h} (${getColorName(h)}): ${hueSigma.toFixed(2)}Ïƒ, count: ${count}`);
                    }
                } else if (zScore > 0.5) {
                    // Without terrain baseline, be VERY sensitive (was 1.0)
                    significantHues.push({ hue: h, score: zScore, count: count });
                    console.log(`  Prominent hue at ${h} (${getColorName(h)}): z-score ${zScore.toFixed(2)}, count: ${count}`);
                }
            }

            // Sort by score, but boost red/orange colors (common SAR targets)
            significantHues.forEach(h => {
                // Boost score for red/orange hues (0-25 and 165-179)
                if ((h.hue >= 0 && h.hue <= 25) || (h.hue >= 165 && h.hue <= 179)) {
                    h.score *= 1.5; // 50% boost for red/orange
                    h.isBoosted = true;
                }
            });
            significantHues.sort((a, b) => b.score - a.score);

            console.log(`Found ${significantHues.length} significant hues`);
            if (significantHues.length > 0) {
                console.log("ALL anomalies detected:");
                significantHues.forEach(h => {
                    console.log(`  ${getColorName(h.hue)} (H${h.hue}) score=${h.score.toFixed(2)}, count=${h.count}`);
                });
                console.log("Top 5 anomalies:", significantHues.slice(0, 5).map(h =>
                    `${getColorName(h.hue)} (H${h.hue}) score=${h.score.toFixed(2)}`));
            }

            // Calculate saturation threshold - use 50th percentile (median) for MAXIMUM sensitivity
            satData.sort((a, b) => a - b);
            const satP50 = satData[Math.floor(satData.length * 0.50)];
            const satP60 = satData[Math.floor(satData.length * 0.60)];
            const satP75 = satData[Math.floor(satData.length * 0.75)];
            const satP90 = satData[Math.floor(satData.length * 0.90)];

            console.log(`Saturation percentiles - P50: ${satP50}, P60: ${satP60}, P75: ${satP75}, P90: ${satP90}`);

            let settingsText = '';

            if (significantHues.length > 0) {
                // Configure detection for top anomalous hues
                const topHues = significantHues.slice(0, 3);

                // Find hue range for top candidate - VERY WIDE range of Â±35 for maximum coverage
                const targetHue = topHues[0].hue;
                let hueMin, hueMax;

                // Special handling for red hues (wraparound)
                if (targetHue <= 15) {
                    // Red at low end
                    hueMin = 0;
                    hueMax = Math.min(179, targetHue + 35);
                } else if (targetHue >= 165) {
                    // Red at high end
                    hueMin = Math.max(0, targetHue - 35);
                    hueMax = 179;
                } else {
                    // Normal hue range
                    hueMin = Math.max(0, targetHue - 35);
                    hueMax = Math.min(179, targetHue + 35);
                }

                // Set HSV Option 1 to target this hue range
                document.getElementById('hsv1-h-min').value = hueMin;
                document.getElementById('hsv1-h-max').value = hueMax;

                // Use 50th percentile (median) saturation for MAXIMUM sensitivity, minimum of 80
                const minSat = Math.max(80, satP50);
                document.getElementById('hsv1-s-min').value = minSat;
                document.getElementById('hsv1-s-max').value = 255;
                document.getElementById('hsv1-v-min').value = 100;
                document.getElementById('hsv1-v-max').value = 255;

                // Enable HSV detection and HSV Option 1
                document.getElementById('enable-hsv').checked = true;
                document.getElementById('hsv1-enabled').checked = true;

                // DISABLE smart filter by default - it may be filtering out the target!
                // User can manually enable if needed
                document.getElementById('enable-smart-filter').checked = false;
                useSmartFilter = false;

                const colorName = getColorName(targetHue);
                settingsText = `Detected anomalous color: <strong>${colorName}</strong> (Hue ${targetHue})<br>`;
                settingsText += `Target range: H${hueMin}-${hueMax}, S>${minSat}<br>`;
                settingsText += `Anomaly score: ${topHues[0].score.toFixed(2)}Ïƒ from terrain baseline<br>`;
                settingsText += `<span class="text-yellow-400">âš  Smart filter DISABLED for max detections - enable manually if too many false positives</span><br>`;

                if (topHues.length > 1) {
                    settingsText += `Also detected: ${topHues.slice(1).map(h => getColorName(h.hue)).join(', ')}`;
                }

                console.log(`Configured detection: H${hueMin}-${hueMax}, S>${minSat}`);
            } else {
                // Fallback: use high saturation detection
                document.getElementById('sat-min').value = satP90;
                document.getElementById('sat-min-val').textContent = satP90;
                document.getElementById('enable-sat').checked = true;
                document.getElementById('enable-hsv').checked = false;

                settingsText = `No strong color anomalies detected.<br>Using high saturation threshold: S>${satP90} (top 10%)`;
                console.log("No anomalies found, using saturation fallback");
            }

            console.log("=== END ANALYSIS ===");

            // Update preview
            updateColorPreviews();

            // Show settings
            document.getElementById('smart-settings-text').innerHTML = settingsText;
            document.getElementById('smart-settings-info').classList.remove('hidden');

            updateStatus("Smart detection configured! Ready to process.", "text-green-400");
        }

        function updateColorPreviews() {
            // Update previews for all HSV options
            updateHSVPreview('hsv1');
            updateHSVPreview('hsv2');
            updateHSVPreview('hsv3');
            updateHSVPreview('hsv-ex');
            updateSaturationPreview();
        }

        // Debounce timer for preview updates
        let previewUpdateTimers = {};

        function updateHSVPreview(prefix) {
            // Clear any pending update for this preview
            if (previewUpdateTimers[prefix]) {
                clearTimeout(previewUpdateTimers[prefix]);
            }

            // Debounce the update - wait 50ms before drawing
            previewUpdateTimers[prefix] = setTimeout(() => {
                drawHSVPreview(prefix);
            }, 50);
        }
        function drawHSVPreview(prefix) {
            const canvas = document.getElementById(`${prefix}-preview`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // Get the actual current values for THIS specific prefix
            const hMinEl = document.getElementById(`${prefix}-h-min`);
            const hMaxEl = document.getElementById(`${prefix}-h-max`);
            const sMinEl = document.getElementById(`${prefix}-s-min`);
            const sMaxEl = document.getElementById(`${prefix}-s-max`);
            const vMinEl = document.getElementById(`${prefix}-v-min`);
            const vMaxEl = document.getElementById(`${prefix}-v-max`);

            if (!hMinEl || !hMaxEl || !sMinEl || !sMaxEl || !vMinEl || !vMaxEl) {
                return;
            }

            const hMin = parseInt(hMinEl.value);
            const hMax = parseInt(hMaxEl.value);
            const sMin = parseInt(sMinEl.value);
            const sMax = parseInt(sMaxEl.value);
            const vMin = parseInt(vMinEl.value);
            const vMax = parseInt(vMaxEl.value);

            // Use mid-range saturation and value for preview
            const previewSat = Math.floor((sMin + sMax) / 2);
            const previewVal = Math.floor((vMin + vMax) / 2);

            // Clear canvas first - THIS IS CRITICAL
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw hue gradient across the canvas
            for (let x = 0; x < canvas.width; x++) {
                // Map x position to hue value (0-179 for OpenCV)
                const hue = Math.floor((x / canvas.width) * 180);

                // Check if this hue is in range
                let inRange = false;
                if (hMin <= hMax) {
                    inRange = (hue >= hMin && hue <= hMax);
                } else {
                    // Wraparound case (e.g., 170-10 includes 170-179 and 0-10)
                    inRange = (hue >= hMin || hue <= hMax);
                }

                if (inRange) {
                    // Convert OpenCV HSV to RGB using proper conversion
                    const rgb = opencvHsvToRgb(hue, previewSat, previewVal);
                    ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                } else {
                    ctx.fillStyle = `rgba(128, 128, 128, 0.2)`;
                }
                ctx.fillRect(x, 0, 1, canvas.height);
            }
        }        

        // Proper OpenCV HSV to RGB conversion
        function opencvHsvToRgb(h, s, v) {
            // OpenCV uses H: 0-179, S: 0-255, V: 0-255
            // Normalize to 0-1 range
            const hNorm = h / 179.0;
            const sNorm = s / 255.0;
            const vNorm = v / 255.0;

            const c = vNorm * sNorm;
            const x = c * (1 - Math.abs(((hNorm * 6) % 2) - 1));
            const m = vNorm - c;

            let r, g, b;
            const hSector = hNorm * 6;

            if (hSector < 1) {
                r = c; g = x; b = 0;
            } else if (hSector < 2) {
                r = x; g = c; b = 0;
            } else if (hSector < 3) {
                r = 0; g = c; b = x;
            } else if (hSector < 4) {
                r = 0; g = x; b = c;
            } else if (hSector < 5) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }
        // function updateSaturationPreview() {
        //     // Saturation Preview
        //     const satCanvas = document.getElementById('sat-preview');
        //     if (!satCanvas) return;

        //     const satCtx = satCanvas.getContext('2d');
        //     const satMinEl = document.getElementById('sat-min');
        //     const satMaxEl = document.getElementById('sat-max');

        //     if (!satMinEl || !satMaxEl) return;

        //     const satMin = parseInt(satMinEl.value);
        //     const satMax = parseInt(satMaxEl.value);

        //     for (let x = 0; x < satCanvas.width; x++) {
        //         const sat = Math.floor((x / satCanvas.width) * 255);
        //         const alpha = sat / 255;

        //         if (sat >= satMin && sat <= satMax) {
        //             satCtx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
        //         } else {
        //             satCtx.fillStyle = `rgba(128, 128, 128, 0.2)`;
        //         }
        //         satCtx.fillRect(x, 0, 1, satCanvas.height);
        //     }
        // }
            let satPreviewTimer = null;

            function updateSaturationPreview() {
                // Clear any pending update
                if (satPreviewTimer) {
                    clearTimeout(satPreviewTimer);
                }

                // Debounce the update
                satPreviewTimer = setTimeout(() => {
                    drawSaturationPreview();
                }, 50);
            }

            function drawSaturationPreview() {
                const satCanvas = document.getElementById('sat-preview');
                if (!satCanvas) return;

                const satCtx = satCanvas.getContext('2d');
                if (!satCtx) return;

                const satMinEl = document.getElementById('sat-min');
                const satMaxEl = document.getElementById('sat-max');

                if (!satMinEl || !satMaxEl) return;

                const satMin = parseInt(satMinEl.value);
                const satMax = parseInt(satMaxEl.value);

                // Clear canvas first - CRITICAL
                satCtx.clearRect(0, 0, satCanvas.width, satCanvas.height);

                // Draw saturation gradient
                for (let x = 0; x < satCanvas.width; x++) {
                    const sat = Math.floor((x / satCanvas.width) * 255);
                    const alpha = sat / 255;

                    if (sat >= satMin && sat <= satMax) {
                        satCtx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
                    } else {
                        satCtx.fillStyle = `rgba(128, 128, 128, 0.2)`;
                    }
                    satCtx.fillRect(x, 0, 1, satCanvas.height);
                }
            }


        function analyzeCurrentFrame() {
            if (!video || !video.videoWidth) {
                alert('Please load a video first');
                return;
            }

            updateStatus("Analyzing current frame...", "text-blue-400");
            document.getElementById('analysis-status').textContent = "Analyzing...";

            try {
                cap.read(srcMat);
                cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                const colorData = analyzeFrame(hsvMat);
                colorAnalysisData = colorData; // Store for "Use as Exclusion"
                drawColorHistogram(colorData);
                document.getElementById('use-as-exclusion-btn').classList.remove('hidden');
                document.getElementById('analysis-status').textContent = "Analysis complete";
                updateStatus("Current frame analyzed", "text-green-400");
            } catch (err) {
                console.error("Analysis error:", err);
                document.getElementById('analysis-status').textContent = "Analysis failed";
                updateStatus("Analysis failed", "text-red-400");
            }
        }

        function analyzeWholeVideo() {
            if (!video || !video.videoWidth) {
                alert('Please load a video first');
                return;
            }

            if (isProcessing) {
                alert('Please pause video processing first');
                return;
            }

            updateStatus("Analyzing whole video (sampling frames)...", "text-indigo-400");
            document.getElementById('analysis-status').textContent = "Analyzing whole video...";

            const savedTime = video.currentTime;
            isSeekingSuppressed = true;

            const duration = video.duration;
            const sampleFrames = 30;
            const frameStep = duration / sampleFrames;

            let allColorData = { hues: [], sats: [] };
            let frameIndex = 0;

            function sampleNext() {
                if (frameIndex >= sampleFrames) {
                    isSeekingSuppressed = false;
                    video.currentTime = savedTime;

                    colorAnalysisData = allColorData; // Store for "Use as Exclusion"
                    drawColorHistogram(allColorData);
                    document.getElementById('use-as-exclusion-btn').classList.remove('hidden');
                    document.getElementById('analysis-status').textContent = "Whole video analysis complete";
                    updateStatus("Whole video analyzed", "text-green-400");
                    return;
                }

                const onSeekedHandler = () => {
                    video.removeEventListener('seeked', onSeekedHandler);

                    try {
                        cap.read(srcMat);
                        cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                        const frameData = analyzeFrame(hsvMat);
                        allColorData.hues.push(...frameData.hues);
                        allColorData.sats.push(...frameData.sats);

                        frameIndex++;
                        document.getElementById('analysis-status').textContent = `Analyzing... ${frameIndex}/${sampleFrames}`;

                        setTimeout(sampleNext, 50);
                    } catch (err) {
                        console.error("Error:", err);
                        isSeekingSuppressed = false;
                        video.currentTime = savedTime;
                    }
                };

                video.addEventListener('seeked', onSeekedHandler, { once: true });
                video.currentTime = Math.min(frameIndex * frameStep, duration - 0.1);
            }

            sampleNext();
        }

        function analyzeFrame(hsvMat) {
            const hues = {};
            const saturations = {};
            const values = {};
            const sats = [];
            const h = hsvMat.rows;
            const w = hsvMat.cols;
            const step = 20;

            for (let y = 0; y < h; y += step) {
                for (let x = 0; x < w; x += step) {
                    const hue = hsvMat.ucharPtr(y, x)[0];
                    const sat = hsvMat.ucharPtr(y, x)[1];
                    const val = hsvMat.ucharPtr(y, x)[2];

                    if (val > 30 && val < 230) {
                        hues[hue] = (hues[hue] || 0) + 1;
                        if (sat > 120) sats.push(sat);
                    }

                    // Collect saturation and value distribution
                    saturations[sat] = (saturations[sat] || 0) + 1;
                    values[val] = (values[val] || 0) + 1;
                }
            }

            return {
                hues: Object.entries(hues).map(([h, c]) => ({h: parseInt(h), count: c})),
                saturations: Object.entries(saturations).map(([s, c]) => ({s: parseInt(s), count: c})),
                values: Object.entries(values).map(([v, c]) => ({v: parseInt(v), count: c})),
                sats
            };
        }

        function drawColorHistogram(colorData) {
            const canvas = document.getElementById('color-histogram');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            // Aggregate hue data
            const hueCounts = new Array(180).fill(0);
            if (colorData.hues && colorData.hues.length > 0) {
                if (Array.isArray(colorData.hues[0])) {
                    // Already aggregated
                    colorData.hues.forEach(([h, c]) => hueCounts[h] = c);
                } else {
                    // Need to aggregate
                    colorData.hues.forEach(item => {
                        if (item.h !== undefined) hueCounts[item.h] += item.count;
                    });
                }
            }

            const maxCount = Math.max(...hueCounts);
            if (maxCount === 0) return;

            // Draw bars
            const barWidth = width / 180;
            for (let h = 0; h < 180; h++) {
                const barHeight = (hueCounts[h] / maxCount) * (height - 40);

                // Color for this hue
                const rgb = hsvToRgb(h, 255, 255);
                ctx.fillStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                ctx.fillRect(h * barWidth, height - barHeight - 20, barWidth, barHeight);
            }

            // Stats
            const statsEl = document.getElementById('analysis-stats');
            const totalPixels = hueCounts.reduce((a, b) => a + b, 0);
            const vividPixels = colorData.sats ? colorData.sats.length : 0;
            const avgSat = colorData.sats && colorData.sats.length > 0
                ? (colorData.sats.reduce((a, b) => a + b, 0) / colorData.sats.length).toFixed(0)
                : 0;

            // Find dominant hue
            let dominantHue = 0;
            let maxHueCount = 0;
            hueCounts.forEach((count, hue) => {
                if (count > maxHueCount) {
                    maxHueCount = count;
                    dominantHue = hue;
                }
            });

            statsEl.innerHTML = `
                <div class="bg-gray-700 p-2 rounded"><strong>Total Pixels:</strong> ${totalPixels.toLocaleString()}</div>
                <div class="bg-gray-700 p-2 rounded"><strong>Vivid Pixels:</strong> ${vividPixels.toLocaleString()}</div>
                <div class="bg-gray-700 p-2 rounded"><strong>Avg Saturation:</strong> ${avgSat}</div>
                <div class="bg-gray-700 p-2 rounded"><strong>Dominant Hue:</strong> ${getColorName(dominantHue)} (${dominantHue})</div>
            `;

            document.getElementById('analysis-chart-container').classList.remove('hidden');

            // Also draw saturation and value histograms
            drawSaturationHistogram(colorData);
            drawValueHistogram(colorData);
        }

        function drawSaturationHistogram(colorData) {
            const canvas = document.getElementById('saturation-histogram');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            // Aggregate saturation data
            const satCounts = new Array(256).fill(0);
            if (colorData.saturations && colorData.saturations.length > 0) {
                colorData.saturations.forEach(item => {
                    if (item.s !== undefined) satCounts[item.s] = item.count;
                });
            }

            const maxCount = Math.max(...satCounts);
            if (maxCount === 0) return;

            // Draw bars
            const barWidth = width / 256;
            for (let s = 0; s < 256; s++) {
                const barHeight = (satCounts[s] / maxCount) * (height - 40);

                // Color gradient from gray (0 sat) to magenta (255 sat)
                const alpha = s / 255;
                ctx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
                ctx.fillRect(s * barWidth, height - barHeight - 20, barWidth, barHeight);
            }

            // Add labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText('0', 5, height - 5);
            ctx.fillText('128', width / 2 - 15, height - 5);
            ctx.fillText('255', width - 30, height - 5);
        }

        function drawValueHistogram(colorData) {
            const canvas = document.getElementById('value-histogram');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.clearRect(0, 0, width, height);

            // Aggregate value data
            const valCounts = new Array(256).fill(0);
            if (colorData.values && colorData.values.length > 0) {
                colorData.values.forEach(item => {
                    if (item.v !== undefined) valCounts[item.v] = item.count;
                });
            }

            const maxCount = Math.max(...valCounts);
            if (maxCount === 0) return;

            // Draw bars
            const barWidth = width / 256;
            for (let v = 0; v < 256; v++) {
                const barHeight = (valCounts[v] / maxCount) * (height - 40);

                // Color gradient from black (0 val) to white (255 val)
                const brightness = v;
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.fillRect(v * barWidth, height - barHeight - 20, barWidth, barHeight);
            }

            // Add labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText('0', 5, height - 5);
            ctx.fillText('128', width / 2 - 15, height - 5);
            ctx.fillText('255', width - 30, height - 5);
        }

        function updateSettingsIndicator() {
            const hsvEnabled = document.getElementById('enable-hsv').checked;
            const satEnabled = document.getElementById('enable-sat').checked;
            const smartFilter = document.getElementById('enable-smart-filter').checked;

            // Get active HSV options
            const hsv1Enabled = document.getElementById('hsv1-enabled')?.checked;
            const hsv2Enabled = document.getElementById('hsv2-enabled')?.checked;
            const hsv3Enabled = document.getElementById('hsv3-enabled')?.checked;

            let activeOptions = [];
            if (hsv1Enabled) activeOptions.push('HSV1');
            if (hsv2Enabled) activeOptions.push('HSV2');
            if (hsv3Enabled) activeOptions.push('HSV3');

            document.getElementById('ind-hsv-enabled').textContent = hsvEnabled ? 'Yes' : 'No';
            document.getElementById('ind-hsv-enabled').className = hsvEnabled ? 'text-green-400' : 'text-gray-500';

            document.getElementById('ind-sat-enabled').textContent = satEnabled ? 'Yes' : 'No';
            document.getElementById('ind-sat-enabled').className = satEnabled ? 'text-purple-400' : 'text-gray-500';

            // Show active HSV options instead of specific ranges
            const hueRangeEl = document.getElementById('ind-hue-range');
            if (hueRangeEl) {
                hueRangeEl.textContent = activeOptions.length > 0 ? activeOptions.join(', ') : 'None';
            }

            const satRangeEl = document.getElementById('ind-sat-range');
            if (satRangeEl) {
                const satMin = document.getElementById('sat-min')?.value || '200';
                const satMax = document.getElementById('sat-max')?.value || '255';
                satRangeEl.textContent = `${satMin}-${satMax}`;
            }

            document.getElementById('ind-smart-filter').textContent = smartFilter ? 'On' : 'Off';
            document.getElementById('ind-smart-filter').className = smartFilter ? 'text-orange-400' : 'text-gray-500';

            const globalFilter = document.getElementById('enable-global-filter').checked;
            document.getElementById('ind-global-filter').textContent = globalFilter ? 'On' : 'Off';
            document.getElementById('ind-global-filter').className = globalFilter ? 'text-purple-400' : 'text-gray-500';

            // Show size range for HSV1 as a reference
            const sizeRangeEl = document.getElementById('ind-size-range');
            if (sizeRangeEl) {
                const sizeMin = document.getElementById('hsv1-min-size')?.value || '200';
                const sizeMax = document.getElementById('hsv1-max-size')?.value || '20000';
                sizeRangeEl.textContent = `${sizeMin}-${sizeMax}px`;
            }

            // Update Exclusion Source
            const exclusionSourceEl = document.getElementById('ind-exclusion-source');
            if (exclusionSourceEl && window.exclusionSource) {
                exclusionSourceEl.textContent = window.exclusionSource;
                exclusionSourceEl.className = 'text-yellow-400';
            } else {
                exclusionSourceEl.textContent = 'None';
                exclusionSourceEl.className = 'text-gray-500';
            }

            // Update DBSCAN status
            const dbscanEl = document.getElementById('ind-dbscan');
            if (dbscanEl) {
                if (window.dbscanUsed) {
                    dbscanEl.textContent = 'Used';
                    dbscanEl.className = 'text-indigo-400';
                } else {
                    dbscanEl.textContent = 'Off';
                    dbscanEl.className = 'text-gray-500';
                }
            }
        }

        function useAnalysisAsExclusion() {
            if (!colorAnalysisData) {
                alert('Please run color analysis first');
                return;
            }

            // Use the current frame's color analysis as terrain baseline
            try {
                cap.read(srcMat);
                cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                const h = hsvMat.rows;
                const w = hsvMat.cols;
                const step = 10; // Finer sampling for better exclusion

                let hueValues = [];
                let satValues = [];
                let valValues = [];

                for (let y = 0; y < h; y += step) {
                    for (let x = 0; x < w; x += step) {
                        const hue = hsvMat.ucharPtr(y, x)[0];
                        const sat = hsvMat.ucharPtr(y, x)[1];
                        const val = hsvMat.ucharPtr(y, x)[2];

                        if (val > 30 && val < 230) {
                            hueValues.push(hue);
                            satValues.push(sat);
                            valValues.push(val);
                        }
                    }
                }

                // Calculate statistics
                const hueMean = hueValues.reduce((a, b) => a + b, 0) / hueValues.length;
                const hueStd = Math.sqrt(hueValues.reduce((sq, n) => sq + Math.pow(n - hueMean, 2), 0) / hueValues.length);

                const satMean = satValues.reduce((a, b) => a + b, 0) / satValues.length;
                const satStd = Math.sqrt(satValues.reduce((sq, n) => sq + Math.pow(n - satMean, 2), 0) / satValues.length);

                // Sort to get percentiles
                hueValues.sort((a, b) => a - b);
                satValues.sort((a, b) => a - b);

                const hueP25 = hueValues[Math.floor(hueValues.length * 0.25)];
                const hueP75 = hueValues[Math.floor(hueValues.length * 0.75)];
                const satP25 = satValues[Math.floor(satValues.length * 0.25)];
                const satP75 = satValues[Math.floor(satValues.length * 0.75)];

                terrainBaseline = {
                    hueMean: hueMean,
                    hueStd: hueStd,
                    hueP25: hueP25,
                    hueP75: hueP75,
                    satMean: satMean,
                    satStd: satStd,
                    satP25: satP25,
                    satP75: satP75
                };

                const filterStrength = document.getElementById('filter-strength').value;
                const infoEl = document.getElementById('terrain-info');
                infoEl.innerHTML = `
                    <strong class="text-orange-400">âœ“ ACTIVE: Exclusion from Current Frame</strong><br>
                    <div class="pl-2 mt-1">
                    <strong>Baseline Statistics:</strong><br>
                    â€¢ Hue: ${hueMean.toFixed(0)} Â± ${hueStd.toFixed(0)}Ïƒ (P25-P75: ${hueP25.toFixed(0)}-${hueP75.toFixed(0)})<br>
                    â€¢ Sat: ${satMean.toFixed(0)} Â± ${satStd.toFixed(0)}Ïƒ (P25-P75: ${satP25.toFixed(0)}-${satP75.toFixed(0)})<br>
                    â€¢ Filter Strength: ${filterStrength}Ïƒ (lower = stricter)<br>
                    <em class="text-yellow-300">Detections matching these ranges will be filtered</em><br>
                    <span class="text-gray-400">To disable: uncheck "Smart Terrain Filter"</span>
                    </div>
                `;
                infoEl.classList.remove('hidden');

                // Set exclusion source
                window.exclusionSource = 'Current Frame';

                // Also update HSV Option 4 sliders with tighter ranges for better exclusion
                // Use percentiles for more robust exclusion (P10-P90 covers most of the frame)
                const valMean = valValues.reduce((a, b) => a + b, 0) / valValues.length;

                document.getElementById('hsv4-h-min').value = Math.max(0, hueP25 - 5);
                document.getElementById('hsv4-h-max').value = Math.min(179, hueP75 + 5);
                document.getElementById('hsv4-s-min').value = Math.max(0, satP25 - 10);
                document.getElementById('hsv4-s-max').value = Math.min(255, satP75 + 10);

                // Also use value range for better exclusion
                valValues.sort((a, b) => a - b);
                const valP25 = valValues[Math.floor(valValues.length * 0.25)];
                const valP75 = valValues[Math.floor(valValues.length * 0.75)];
                document.getElementById('hsv4-v-min').value = Math.max(0, valP25 - 20);
                document.getElementById('hsv4-v-max').value = Math.min(255, valP75 + 20);

                // Trigger update events
                document.getElementById('hsv4-h-min').dispatchEvent(new Event('input'));
                document.getElementById('hsv4-h-max').dispatchEvent(new Event('input'));
                document.getElementById('hsv4-s-min').dispatchEvent(new Event('input'));
                document.getElementById('hsv4-s-max').dispatchEvent(new Event('input'));
                document.getElementById('hsv4-v-min').dispatchEvent(new Event('input'));
                document.getElementById('hsv4-v-max').dispatchEvent(new Event('input'));

                // Enable HSV Option 4 and set to exclude mode
                document.getElementById('hsv4-enabled').checked = true;
                document.querySelector('input[name="hsv4-mode"][value="exclude"]').checked = true;

                // Enable smart filter
                document.getElementById('enable-smart-filter').checked = true;
                useSmartFilter = true;
                updateSettingsIndicator();

                updateStatus("Current frame set as exclusion baseline. Smart filter enabled. Reprocessing...", "text-green-400");

                // Clear current detections from the display
                batchDetections = [];
                document.getElementById('detection-list').innerHTML = '';
                document.getElementById('detection-list-container').classList.add('hidden');

                // Reprocess current frame with new exclusion
                if (!isProcessing) {
                    processSingleFrame();
                }

            } catch (err) {
                console.error("Error setting exclusion:", err);
                updateStatus("Failed to set exclusion baseline", "text-red-400");
            }
        }

        function hsvToRgb(h, s, v) {
            s /= 255; v /= 255;
            const c = v * s;
            const x = c * (1 - Math.abs(((h * 2) % 120) / 60 - 1));
            const m = v - c;
            let r, g, b;

            if (h < 30) { r = c; g = x; b = 0; }
            else if (h < 60) { r = x; g = c; b = 0; }
            else if (h < 90) { r = 0; g = c; b = x; }
            else if (h < 120) { r = 0; g = x; b = c; }
            else if (h < 150) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }

        // --- FIXED FUNCTION ---
        function batchProcessVideo() {
            if (!video || !video.videoWidth) {
                alert('Please load a video first');
                return;
            }

            if (isProcessing) {
                alert('Please pause video processing first');
                return;
            }

            const detectionMode = document.getElementById('detection-mode').value;
            const smartSettingsVisible = !document.getElementById('smart-settings-info').classList.contains('hidden');
            const dbscanSettingsVisible = !document.getElementById('dbscan-info').classList.contains('hidden');

            // If smart mode and NEITHER analysis has been run, run quick analyze first
            if (detectionMode === 'smart' && !smartSettingsVisible && !dbscanSettingsVisible) {
                updateStatus("Running smart analysis before batch processing...", "text-indigo-400");
                quickAnalyzeAndConfigure();

                // Wait for analysis to complete, then start batch
                const checkInterval = setInterval(() => {
                    // Check if EITHER setting block is now visible
                    const newSmartVisible = !document.getElementById('smart-settings-info').classList.contains('hidden');
                    const newDbscanVisible = !document.getElementById('dbscan-info').classList.contains('hidden');
                    
                    if (newSmartVisible || newDbscanVisible) {
                        clearInterval(checkInterval);
                        setTimeout(() => startBatchProcessing(), 1000);
                    }
                }, 500);
                return;
            }

            startBatchProcessing();
        }
        // --- END FIXED FUNCTION ---

        function startBatchProcessing() {
            const sampleRate = parseInt(document.getElementById('frame-sample-rate').value);
            const duration = video.duration;
            const totalFrames = Math.floor(duration * fps);
            const framesToProcess = Math.floor(totalFrames / sampleRate);

            const enableHsv = document.getElementById('enable-hsv').checked;
            const enableSat = document.getElementById('enable-sat').checked;
            const enableDbscan = document.getElementById('use-dbscan').checked;

            if (!enableHsv && !enableSat && !enableDbscan) {
                alert('Please enable at least one detection method (HSV, High Saturation, or DBSCAN)');
                return;
            }

            batchDetections = [];
            const savedTime = video.currentTime;
            isSeekingSuppressed = true;

            // Show and reset progress bar
            const progressEl = document.getElementById('batch-progress');
            progressEl.classList.remove('hidden');
            document.getElementById('batch-progress-bar').style.width = '0%';
            document.getElementById('batch-progress-text').textContent = 'Starting...';
            console.log('Batch progress bar shown:', !progressEl.classList.contains('hidden'));

            document.getElementById('batch-process-btn').disabled = true;
            updateStatus("Batch processing in progress...", "text-purple-400");

            let frameIndex = 0;

            function processNext() {
                if (frameIndex >= framesToProcess) {
                    // Complete
                    console.log(`Batch processing complete. Total detections: ${batchDetections.length}`);
                    isSeekingSuppressed = false;
                    video.currentTime = savedTime;
                    document.getElementById('batch-process-btn').disabled = false;
                    document.getElementById('batch-progress').classList.add('hidden');

                    displayDetectionList();
                    updateStatus(`Batch processing complete. Found ${batchDetections.length} frames with detections.`, "text-green-400");
                    return;
                }

                const frameNum = frameIndex * sampleRate;
                const timePos = frameNum / fps;

                const onSeekedHandler = () => {
                    video.removeEventListener('seeked', onSeekedHandler);

                    try {
                        const dets = detectionsForCurrentFrame(frameNum);
                        console.log(`Frame ${frameNum}: Found ${dets.length} detections`);

                        // Capture thumbnail with detections drawn
                        if (dets.length > 0) {
                            // Draw detections on a copy
                            let displayMat = srcMat.clone();

                            console.log(`Creating thumbnail for frame ${frameNum} with ${dets.length} detections`);
                            console.log(`srcMat: ${srcMat.cols}x${srcMat.rows}, displayMat: ${displayMat.cols}x${displayMat.rows}`);

                            dets.forEach((det, i) => {
                                console.log(`  Det ${i}: ${det.type} at (${det.rect.x},${det.rect.y}) size ${det.rect.width}x${det.rect.height}`);
                                
                                let color = [0, 255, 0, 255]; // Default green
                                if (det.type === 'Sat') {
                                    color = [255, 0, 255, 255]; // Magenta
                                } else if (det.type === 'DBSCAN') {
                                    color = [0, 191, 255, 255]; // Deep Sky Blue
                                }

                                // Handle HSV1, HSV2, HSV3, or just HSV
                            //     if (det.type && det.type.startsWith('HSV')) {
                            //         cv.rectangle(displayMat,
                            //             new cv.Point(det.rect.x, det.rect.y),
                            //             new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                            //             [0, 255, 0, 255], 2, cv.LINE_AA, 0);

                            //         // Add label with detection details
                            //         const label = `${det.type}: ${det.desc} (${det.area}px)`;
                            //         cv.putText(displayMat, label,
                            //             new cv.Point(det.rect.x, det.rect.y - 5),
                            //             cv.FONT_HERSHEY_SIMPLEX, 0.4, [0, 255, 0, 255], 1, cv.LINE_AA);
                            //     } else if (det.type === 'Sat') {
                            //         cv.rectangle(displayMat,
                            //             new cv.Point(det.rect.x, det.rect.y),
                            //             new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                            //             [255, 0, 255, 255], 2, cv.LINE_AA, 0);

                            //         // Add label with detection details
                            //         const label = `${det.type}: ${det.desc} (${det.area}px)`;
                            //         cv.putText(displayMat, label,
                            //             new cv.Point(det.rect.x, det.rect.y - 5),
                            //             cv.FONT_HERSHEY_SIMPLEX, 0.4, [255, 0, 255, 255], 1, cv.LINE_AA);
                            //     } else if (det.type === 'DBSCAN') {
                            //          cv.rectangle(displayMat,
                            //             new cv.Point(det.rect.x, det.rect.y),
                            //             new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                            //             [0, 191, 255, 255], 2, cv.LINE_AA, 0);

                            //         // Add label with detection details
                            //         const label = `${det.type}: ${det.desc} (${det.area}px)`;
                            //         cv.putText(displayMat, label,
                            //             new cv.Point(det.rect.x, det.rect.y - 5),
                            //             cv.FONT_HERSHEY_SIMPLEX, 0.4, [0, 191, 255, 255], 1, cv.LINE_AA);
                            //     }
                            // });
                            if (det.type && det.type.startsWith('HSV')) {
                                    cv.rectangle(displayMat,
                                        new cv.Point(det.rect.x, det.rect.y),
                                        new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                                        [0, 255, 0, 255], 2, cv.LINE_AA, 0);

                                    // Add label with detection details
                                    const label = `${det.type}: ${det.desc} (${det.area}px)`;
                                    cv.putText(displayMat, label,
                                        new cv.Point(det.rect.x, det.rect.y - 5),
                                        cv.FONT_HERSHEY_SIMPLEX, 0.4, [0, 255, 0, 255], 1, cv.LINE_AA);
                                } else if (det.type === 'Sat') {
                                    cv.rectangle(displayMat,
                                        new cv.Point(det.rect.x, det.rect.y),
                                        new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                                        [255, 0, 255, 255], 2, cv.LINE_AA, 0);

                                    // Add label with detection details
                                    const label = `${det.type}: ${det.desc} (${det.area}px)`;
                                    cv.putText(displayMat, label,
                                        new cv.Point(det.rect.x, det.rect.y - 5),
                                        cv.FONT_HERSHEY_SIMPLEX, 0.4, [255, 0, 255, 255], 1, cv.LINE_AA);
                                } else if (det.type === 'DBSCAN') {
                                    cv.rectangle(displayMat,
                                        new cv.Point(det.rect.x, det.rect.y),
                                        new cv.Point(det.rect.x + det.rect.width, det.rect.y + det.rect.height),
                                        [0, 191, 255, 255], 2, cv.LINE_AA, 0); // Deep Sky Blue

                                    // Add label with detection details
                                    const label = `${det.type}: ${det.desc} (${det.area}px)`;
                                    cv.putText(displayMat, label,
                                        new cv.Point(det.rect.x, det.rect.y - 5),
                                        cv.FONT_HERSHEY_SIMPLEX, 0.4, [0, 191, 255, 255], 1, cv.LINE_AA);
                                }
                            });

                            // Convert to thumbnail
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = displayMat.cols;
                            tempCanvas.height = displayMat.rows;
                            cv.imshow(tempCanvas, displayMat);
                            const thumbnail = tempCanvas.toDataURL('image/jpeg', 0.7);

                            console.log(`Thumbnail created: ${thumbnail.substring(0, 50)}... (${thumbnail.length} chars)`);

                            displayMat.delete();

                            batchDetections.push({
                                frame: frameNum,
                                time: timePos,
                                detections: dets,
                                thumbnail: thumbnail
                            });
                        }

                        frameIndex++;
                        const progress = (frameIndex / framesToProcess) * 100;
                        document.getElementById('batch-progress-bar').style.width = progress + '%';
                        document.getElementById('batch-progress-text').textContent =
                            `Processing frame ${frameNum} / ${totalFrames} (${Math.round(progress)}%)`;

                        setTimeout(processNext, 10);
                    } catch (err) {
                        console.error("Batch error:", err);
                        isSeekingSuppressed = false;
                        video.currentTime = savedTime;
                        document.getElementById('batch-process-btn').disabled = false;
                    }
                };

                video.addEventListener('seeked', onSeekedHandler, { once: true });
                video.currentTime = Math.min(timePos, duration - 0.1);
            }

            processNext();
        }

        function detectionsForCurrentFrame(frameNum) {
            const detections = [];

            try {
                // Validate Mats are available and not deleted
                if (!srcMat || !rgbMat || !hsvMat || !cap) {
                    console.warn("Mats not initialized, skipping frame");
                    return detections;
                }

                cap.read(srcMat);
                if (srcMat.empty()) {
                    console.warn("Empty frame, skipping");
                    return detections;
                }

                cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                const enableHsv = document.getElementById('enable-hsv').checked;
                const enableSat = document.getElementById('enable-sat').checked;

                // Multi-HSV Detection
                if (enableHsv) {
                    const hsvOptions = [
                        { prefix: 'hsv1', enabled: document.getElementById('hsv1-enabled')?.checked, mode: document.querySelector('input[name="hsv1-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv2', enabled: document.getElementById('hsv2-enabled')?.checked, mode: document.querySelector('input[name="hsv2-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv3', enabled: document.getElementById('hsv3-enabled')?.checked, mode: document.querySelector('input[name="hsv3-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv4', enabled: document.getElementById('hsv4-enabled')?.checked, mode: document.querySelector('input[name="hsv4-mode"]:checked')?.value || 'include' }
                    ];

                    for (const option of hsvOptions) {
                        if (!option.enabled) continue;

                        const hMin = parseInt(document.getElementById(`${option.prefix}-h-min`)?.value || 0);
                        const hMax = parseInt(document.getElementById(`${option.prefix}-h-max`)?.value || 179);
                        const sMin = parseInt(document.getElementById(`${option.prefix}-s-min`)?.value || 0);
                        const sMax = parseInt(document.getElementById(`${option.prefix}-s-max`)?.value || 255);
                        const vMin = parseInt(document.getElementById(`${option.prefix}-v-min`)?.value || 0);
                        const vMax = parseInt(document.getElementById(`${option.prefix}-v-max`)?.value || 255);
                        const minSize = parseInt(document.getElementById(`${option.prefix}-min-size`)?.value || 200);
                        const maxSize = parseInt(document.getElementById(`${option.prefix}-max-size`)?.value || 20000);

                        let lowMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [hMin, sMin, vMin, 0]);
                        let highMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [hMax, sMax, vMax, 0]);
                        let optionMask = new cv.Mat();
                        cv.inRange(hsvMat, lowMat, highMat, optionMask);
                        lowMat.delete();
                        highMat.delete();

                        // If exclude mode, invert the mask
                        if (option.mode === 'exclude') {
                            cv.bitwise_not(optionMask, optionMask);
                        }

                        if (contours) {
                            for (let i = 0; i < contours.size(); ++i) contours.get(i).delete();
                            contours.delete();
                        }
                        contours = new cv.MatVector();
                        cv.findContours(optionMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                        for (let i = 0; i < contours.size(); ++i) {
                            const contour = contours.get(i);
                            const area = cv.contourArea(contour, false);

                            if (area >= minSize && area <= maxSize) {
                                let rect = cv.boundingRect(contour);
                                const cx = rect.x + Math.floor(rect.width / 2);
                                const cy = rect.y + Math.floor(rect.height / 2);

                                const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                const detVal = hsvMat.ucharPtr(cy, cx)[2];

                                let skipDetection = false;

                                // Check if color is excluded (old system)
                                if (isExcludedColor(detHue)) skipDetection = true;

                                // Check if color matches terrain baseline
                                if (useSmartFilter && isTerrainColor(detHue, detSat)) skipDetection = true;
                                
                                // Check if color is within global distribution
                                if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) skipDetection = true;

                                if (skipDetection) continue;

                                const colorName = getColorName(detHue);
                                detections.push({
                                    type: option.prefix.toUpperCase(),
                                    desc: `${colorName} H${detHue} S${detSat}`,
                                    area: Math.round(area),
                                    rect: rect
                                });
                            }
                        }

                        optionMask.delete();
                    }

                }

                // High Saturation Detection
                if (enableSat) {
                    const satMin = parseInt(document.getElementById('sat-min').value);
                    const minSize = parseInt(document.getElementById('sat-min-size').value);
                    const maxSize = parseInt(document.getElementById('sat-max-size').value);

                    let satChannel = new cv.MatVector();
                    cv.split(hsvMat, satChannel);
                    let sat = satChannel.get(1);
                    let satMask = new cv.Mat();
                    let satLow = new cv.Mat(sat.rows, sat.cols, sat.type(), new cv.Scalar(satMin));
                    let satHigh = new cv.Mat(sat.rows, sat.cols, sat.type(), new cv.Scalar(255));
                    cv.inRange(sat, satLow, satHigh, satMask);
                    satLow.delete();
                    satHigh.delete();
                    sat.delete();
                    satChannel.delete();

                    if (contours) {
                        for (let i = 0; i < contours.size(); ++i) contours.get(i).delete();
                        contours.delete();
                    }
                    contours = new cv.MatVector();
                    cv.findContours(satMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                    for (let i = 0; i < contours.size(); ++i) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour, false);

                        if (area >= minSize && area <= maxSize) {
                            let rect = cv.boundingRect(contour);
                            const cx = rect.x + Math.floor(rect.width / 2);
                            const cy = rect.y + Math.floor(rect.height / 2);

                            const detHue = hsvMat.ucharPtr(cy, cx)[0];
                            const detSat = hsvMat.ucharPtr(cy, cx)[1];
                            const detVal = hsvMat.ucharPtr(cy, cx)[2];

                            // Check if color is excluded
                            if (isExcludedColor(detHue)) continue;

                            // Check if color matches terrain baseline
                            if (useSmartFilter && isTerrainColor(detHue, detSat)) continue;
                            
                            // Check if color is within global distribution
                            if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) continue;

                            detections.push({
                                type: 'Sat',
                                desc: `S${detSat}`,
                                area: Math.round(area),
                                rect: rect
                            });
                        }
                    }

                    satMask.delete();
                }
                // DBSCAN Detection
                if (document.getElementById('use-dbscan').checked && window.dbscanAnomalyTargets && window.dbscanAnomalyTargets.length > 0) {
                    
                    for (const target of window.dbscanAnomalyTargets) {
                        let lowMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [target.hMin, target.sMin, target.vMin, 0]);
                        let highMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [target.hMax, target.sMax, target.vMax, 0]);

                        let dbscanMask = new cv.Mat();
                        cv.inRange(hsvMat, lowMat, highMat, dbscanMask);
                        
                        lowMat.delete();
                        highMat.delete();

                        if (contours) {
                            for (let i = 0; i < contours.size(); ++i) contours.get(i).delete();
                            contours.delete();
                        }
                        contours = new cv.MatVector();

                        cv.findContours(dbscanMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                        for (let i = 0; i < contours.size(); ++i) {
                            const contour = contours.get(i);
                            const area = cv.contourArea(contour, false);

                            if (area >= target.minSize && area <= target.maxSize) {
                                let rect = cv.boundingRect(contour);
                                const cx = rect.x + Math.floor(rect.width / 2);
                                const cy = rect.y + Math.floor(rect.height / 2);

                                let skipDetection = false;
                                if (cx < hsvMat.cols && cy < hsvMat.rows) {
                                    const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                    const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                    const detVal = hsvMat.ucharPtr(cy, cx)[2];
                                    
                                    // Smart filter check
                                    if (useSmartFilter && isTerrainColor(detHue, detSat)) skipDetection = true;
                                    
                                    // Global filter check
                                    if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) skipDetection = true;
                                }

                                if (skipDetection) continue;

                                // Add detection
                                detections.push({
                                    type: 'DBSCAN',
                                    desc: target.label,
                                    area: Math.round(area),
                                    rect: rect
                                });
                            }
                        }
                        dbscanMask.delete();
                    }
                }

            } catch (err) {
                console.error("Detection error:", err);
            }

            return detections;
        }

        let currentModalIndex = 0;

        function openDetectionModal(index) {
            currentModalIndex = index;
            const detection = batchDetections[index];

            // Seek video to this frame's time
            if (!isProcessing && video) {
                const onSeekForModal = () => {
                    video.removeEventListener('seeked', onSeekForModal);
                    try {
                        processSingleFrame();
                    } catch (err) {
                        console.error("Error processing frame for modal:", err);
                    }
                };
                video.addEventListener('seeked', onSeekForModal, { once: true });
                video.currentTime = detection.time;
            }

            showDetectionInModal(index);

            const modal = document.getElementById('canvas-modal');
            const prevBtn = document.getElementById('modal-prev');
            const nextBtn = document.getElementById('modal-next');
            const modalInfo = document.getElementById('modal-info');

            modal.classList.remove('hidden');
            prevBtn.classList.remove('hidden');
            nextBtn.classList.remove('hidden');
            modalInfo.classList.remove('hidden');

            // Update button visibility
            prevBtn.style.visibility = index > 0 ? 'visible' : 'hidden';
            nextBtn.style.visibility = index < batchDetections.length - 1 ? 'visible' : 'hidden';
        }

        function showDetectionInModal(index) {
            if (index < 0 || index >= batchDetections.length) return;

            const detection = batchDetections[index];
            const modalCanvas = document.getElementById('modal-canvas');
            const modalInfo = document.getElementById('modal-info');

            // Load thumbnail into modal
            const img = new Image();
            img.onload = () => {
                modalCanvas.width = img.width;
                modalCanvas.height = img.height;
                const ctx = modalCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
            };
            img.src = detection.thumbnail;

            // Update info
            modalInfo.textContent = `Frame ${detection.frame} (${detection.time.toFixed(2)}s) - ${detection.detections.length} detections - ${index + 1}/${batchDetections.length}`;
        }

        function navigateModal(direction) {
            const newIndex = currentModalIndex + direction;
            if (newIndex >= 0 && newIndex < batchDetections.length) {
                currentModalIndex = newIndex;
                const detection = batchDetections[newIndex];

                // Seek video to this frame's time
                if (!isProcessing && video) {
                    const onSeekNav = () => {
                        video.removeEventListener('seeked', onSeekNav);
                        try {
                            processSingleFrame();
                        } catch (err) {
                            console.error("Error processing frame during navigation:", err);
                        }
                    };
                    video.addEventListener('seeked', onSeekNav, { once: true });
                    video.currentTime = detection.time;
                }

                showDetectionInModal(newIndex);

                // Update button visibility
                const prevBtn = document.getElementById('modal-prev');
                const nextBtn = document.getElementById('modal-next');
                prevBtn.style.visibility = newIndex > 0 ? 'visible' : 'hidden';
                nextBtn.style.visibility = newIndex < batchDetections.length - 1 ? 'visible' : 'hidden';
            }
        }

        function displayDetectionList() {
            const listContainer = document.getElementById('detection-list');
            listContainer.innerHTML = '';

            if (batchDetections.length === 0) {
                listContainer.innerHTML = '<div class="col-span-full text-center text-gray-400 p-4">No detections found</div>';
                document.getElementById('detection-list-container').classList.remove('hidden');
                return;
            }

            batchDetections.forEach((frameData, idx) => {
                const frameCard = document.createElement('div');
                frameCard.className = 'bg-gray-800 rounded overflow-hidden hover:ring-2 hover:ring-sky-400 transition-all cursor-pointer';

                // Create thumbnail image
                const thumbnailImg = document.createElement('img');
                thumbnailImg.src = frameData.thumbnail;
                thumbnailImg.className = 'w-full h-auto';
                thumbnailImg.alt = `Frame ${frameData.frame}`;

                // Create minimal info section - just frame number and count
                const infoDiv = document.createElement('div');
                infoDiv.className = 'p-2';

                const frameInfo = document.createElement('div');
                frameInfo.className = 'text-xs text-sky-400 font-semibold';
                frameInfo.textContent = `Frame ${frameData.frame} (${frameData.time.toFixed(2)}s) - ${frameData.detections.length} detections`;

                infoDiv.appendChild(frameInfo);

                frameCard.appendChild(thumbnailImg);
                frameCard.appendChild(infoDiv);

                // Click handler to open in modal
                frameCard.addEventListener('click', () => {
                    openDetectionModal(idx);
                    // Update the current frame detections display
                    updateCurrentFrameDetections(frameData.detections);
                });

                listContainer.appendChild(frameCard);
            });

            document.getElementById('detection-list-container').classList.remove('hidden');
        }

        function updateCurrentFrameDetections(detections) {
            const container = document.getElementById('current-frame-detections');
            const listDiv = document.getElementById('current-detections-list');

            if (!detections || detections.length === 0) {
                container.classList.add('hidden');
                return;
            }

            listDiv.innerHTML = '';
            detections.forEach(det => {
                const detLine = document.createElement('div');
                detLine.className = 'text-xs';
                
                let colorClass = 'text-green-400';
                if (det.type === 'Sat') {
                    colorClass = 'text-purple-400';
                } else if (det.type === 'DBSCAN') {
                    colorClass = 'text-indigo-400';
                }
                
                detLine.innerHTML = `<span class="${colorClass}">${det.type}:</span> ${det.desc} <span class="text-gray-500">(${det.area}px)</span>`;
                listDiv.appendChild(detLine);
            });

            container.classList.remove('hidden');
        }

        function startProcessing() {
            isProcessing = true;
            video.play();
            updateStatus("Processing...", "text-sky-400");
            document.getElementById('start-btn').innerHTML = "â¸ Pause";
            document.getElementById('start-btn').classList.replace('bg-green-600', 'bg-yellow-600');
            document.getElementById('start-btn').classList.replace('hover:bg-green-700', 'hover:bg-yellow-700');
            
            then = Date.now();
            requestAnimationFrame(processVideoFrame);
        }

        function pauseProcessing() {
            isProcessing = false;
            video.pause();
            updateStatus("Paused. Press Start to resume.", "text-yellow-400");
            document.getElementById('start-btn').innerHTML = "â–¶ Start";
            document.getElementById('start-btn').classList.replace('bg-yellow-600', 'bg-green-600');
            document.getElementById('start-btn').classList.replace('hover:bg-yellow-700', 'hover:bg-green-700');
        }

        function processVideoFrame() {
            if (!isProcessing) {
                return;
            }

            now = Date.now();
            elapsed = now - then;
            let frameInterval = 1000 / fps;

            if (elapsed > frameInterval) {
                then = now - (elapsed % frameInterval);
                processSingleFrame();
            }

            requestAnimationFrame(processVideoFrame);
        }
        
        function analyzeTerrain() {
            if (isProcessing) {
                alert('Please pause video processing first');
                return;
            }
            
            const savedTime = video.currentTime; // Save current position
            isSeekingSuppressed = true; // Prevent slider updates

            const sampleFrames = parseInt(document.getElementById('terrain-frames').value) || 20;
            updateStatus(`Analyzing terrain colors (sampling ${sampleFrames} frames)...`, "text-orange-400");

            const duration = video.duration;
            const frameStep = duration / sampleFrames;
            
            let hueValues = [];
            let satValues = [];
            
            let frameIndex = 0;
            
            function sampleNextFrame() {
                if (frameIndex >= sampleFrames) {
                    // Analysis complete - restore position
                    const restoreHandler = () => {
                        video.removeEventListener('seeked', restoreHandler);
                        isSeekingSuppressed = false;
                        
                        // Calculate statistics
                        const hueMean = hueValues.reduce((a, b) => a + b, 0) / hueValues.length;
                        const hueStd = Math.sqrt(hueValues.reduce((sq, n) => sq + Math.pow(n - hueMean, 2), 0) / hueValues.length);
                        
                        const satMean = satValues.reduce((a, b) => a + b, 0) / satValues.length;
                        const satStd = Math.sqrt(satValues.reduce((sq, n) => sq + Math.pow(n - satMean, 2), 0) / satValues.length);
                        
                        // Sort to get percentiles
                        hueValues.sort((a, b) => a - b);
                        satValues.sort((a, b) => a - b);
                        
                        const hueP25 = hueValues[Math.floor(hueValues.length * 0.25)];
                        const hueP75 = hueValues[Math.floor(hueValues.length * 0.75)];
                        const satP25 = satValues[Math.floor(satValues.length * 0.25)];
                        const satP75 = satValues[Math.floor(satValues.length * 0.75)];
                        
                        terrainBaseline = {
                            hueMean: hueMean,
                            hueStd: hueStd,
                            hueP25: hueP25,
                            hueP75: hueP75,
                            satMean: satMean,
                            satStd: satStd,
                            satP25: satP25,
                            satP75: satP75
                        };
                        
                        const filterStrength = document.getElementById('filter-strength').value;
                        const smartFilterEnabled = document.getElementById('enable-smart-filter').checked;
                        const terrainFrames = document.getElementById('terrain-frames').value;
                        const infoEl = document.getElementById('terrain-info');
                        infoEl.innerHTML = `
                            <strong class="${smartFilterEnabled ? 'text-orange-400' : 'text-gray-400'}">${smartFilterEnabled ? 'âœ“ ACTIVE' : 'â—‹ INACTIVE'}: Terrain from Whole Video (${terrainFrames} frames)</strong><br>
                            <div class="pl-2 mt-1">
                            <strong>Baseline Statistics:</strong><br>
                            â€¢ Hue: ${hueMean.toFixed(0)} Â± ${hueStd.toFixed(0)}Ïƒ (P25-P75: ${hueP25.toFixed(0)}-${hueP75.toFixed(0)})<br>
                            â€¢ Sat: ${satMean.toFixed(0)} Â± ${satStd.toFixed(0)}Ïƒ (P25-P75: ${satP25.toFixed(0)}-${satP75.toFixed(0)})<br>
                            â€¢ Filter Strength: ${filterStrength}Ïƒ (lower = stricter)<br>
                            <em class="text-yellow-300">Detections matching these ranges will be filtered</em><br>
                            <span class="text-gray-400">To ${smartFilterEnabled ? 'disable' : 'enable'}: ${smartFilterEnabled ? 'uncheck' : 'check'} "Smart Terrain Filter" checkbox above</span>
                            </div>
                        `;
                        infoEl.classList.remove('hidden');

                        // Set exclusion source
                        window.exclusionSource = 'Whole Video (' + terrainFrames + ' frames)';
                        updateSettingsIndicator();

                        updateStatus("Terrain analysis complete! " + (smartFilterEnabled ? "Filter active." : "Enable Smart Filter checkbox to use."), "text-green-400");
                        
                        // Redraw current frame
                        if (!isProcessing) processSingleFrame();
                    };
                    
                    video.addEventListener('seeked', restoreHandler, { once: true });
                    video.currentTime = savedTime;
                    return;
                }
                
                const seekTime = frameIndex * frameStep;
                
                const onSeekedHandler = () => {
                    video.removeEventListener('seeked', onSeekedHandler);
                    
                    try {
                        cap.read(srcMat);
                        cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);
                        
                        // Sample pixels in a grid pattern
                        const h = hsvMat.rows;
                        const w = hsvMat.cols;
                        const step = 30;
                        
                        for (let y = 0; y < h; y += step) {
                            for (let x = 0; x < w; x += step) {
                                const hue = hsvMat.ucharPtr(y, x)[0];
                                const sat = hsvMat.ucharPtr(y, x)[1];
                                const val = hsvMat.ucharPtr(y, x)[2];
                                
                                if (val > 30 && val < 230) {
                                    hueValues.push(hue);
                                    satValues.push(sat);
                                }
                            }
                        }
                        
                        frameIndex++;
                        updateStatus(`Analyzing terrain... ${frameIndex}/${sampleFrames}`, "text-orange-400");
                        
                        setTimeout(sampleNextFrame, 50);
                        
                    } catch (err) {
                        console.error("Error during terrain analysis:", err);
                        updateStatus("Error during terrain analysis", "text-red-400");
                        isSeekingSuppressed = false;
                        video.currentTime = savedTime;
                    }
                };
                
                video.addEventListener('seeked', onSeekedHandler, { once: true });
                video.currentTime = Math.min(seekTime, duration - 0.1);
            }
            
            sampleNextFrame();
        }
        
        function analyzeGlobalDistribution() {
            if (isProcessing) {
                alert('Please pause video processing first');
                return;
            }
            
            const savedTime = video.currentTime;
            isSeekingSuppressed = true;

            const sampleFrames = parseInt(document.getElementById('global-frames').value) || 50;
            updateStatus(`Analyzing global HSV distribution (sampling ${sampleFrames} frames)...`, "text-purple-400");

            const duration = video.duration;
            const frameStep = duration / sampleFrames;
            
            let hueValues = [];
            let satValues = [];
            let valValues = [];
            
            let frameIndex = 0;
            
            function sampleNextFrame() {
                if (frameIndex >= sampleFrames) {
                    // Analysis complete
                    const restoreHandler = () => {
                        video.removeEventListener('seeked', restoreHandler);
                        isSeekingSuppressed = false;
                        
                        // Calculate comprehensive statistics
                        const hueMean = hueValues.reduce((a, b) => a + b, 0) / hueValues.length;
                        const hueStd = Math.sqrt(hueValues.reduce((sq, n) => sq + Math.pow(n - hueMean, 2), 0) / hueValues.length);
                        
                        const satMean = satValues.reduce((a, b) => a + b, 0) / satValues.length;
                        const satStd = Math.sqrt(satValues.reduce((sq, n) => sq + Math.pow(n - satMean, 2), 0) / satValues.length);
                        
                        const valMean = valValues.reduce((a, b) => a + b, 0) / valValues.length;
                        const valStd = Math.sqrt(valValues.reduce((sq, n) => sq + Math.pow(n - valMean, 2), 0) / valValues.length);
                        
                        // Sort for percentiles
                        hueValues.sort((a, b) => a - b);
                        satValues.sort((a, b) => a - b);
                        valValues.sort((a, b) => a - b);
                        
                        const threshold = parseInt(document.getElementById('global-threshold').value) || 90;
                        const percentile = threshold / 100;
                        
                        // Get percentile boundaries
                        const hueMin = hueValues[Math.floor(hueValues.length * (1 - percentile) / 2)];
                        const hueMax = hueValues[Math.floor(hueValues.length * (1 - (1 - percentile) / 2))];
                        const satMin = satValues[Math.floor(satValues.length * (1 - percentile) / 2)];
                        const satMax = satValues[Math.floor(satValues.length * (1 - (1 - percentile) / 2))];
                        const valMin = valValues[Math.floor(valValues.length * (1 - percentile) / 2)];
                        const valMax = valValues[Math.floor(valValues.length * (1 - (1 - percentile) / 2))];
                        
                        globalHsvDistribution = {
                            hueMean: hueMean,
                            hueStd: hueStd,
                            hueMin: hueMin,
                            hueMax: hueMax,
                            satMean: satMean,
                            satStd: satStd,
                            satMin: satMin,
                            satMax: satMax,
                            valMean: valMean,
                            valStd: valStd,
                            valMin: valMin,
                            valMax: valMax,
                            threshold: threshold
                        };
                        
                        const globalFilterEnabled = document.getElementById('enable-global-filter').checked;
                        const stdDevs = document.getElementById('global-std').value;
                        const infoEl = document.getElementById('global-info');
                        infoEl.innerHTML = `
                            <strong class="${globalFilterEnabled ? 'text-purple-400' : 'text-gray-400'}">${globalFilterEnabled ? 'âœ“ ACTIVE' : 'â—‹ INACTIVE'}: Global Distribution (${sampleFrames} frames, ${threshold}%ile)</strong><br>
                            <div class="pl-2 mt-1">
                            <strong>Distribution Statistics:</strong><br>
                            â€¢ Hue: ${hueMean.toFixed(0)} Â± ${hueStd.toFixed(0)}Ïƒ (Range: ${hueMin.toFixed(0)}-${hueMax.toFixed(0)})<br>
                            â€¢ Sat: ${satMean.toFixed(0)} Â± ${satStd.toFixed(0)}Ïƒ (Range: ${satMin.toFixed(0)}-${satMax.toFixed(0)})<br>
                            â€¢ Val: ${valMean.toFixed(0)} Â± ${valStd.toFixed(0)}Ïƒ (Range: ${valMin.toFixed(0)}-${valMax.toFixed(0)})<br>
                            â€¢ Exclusion: Within ${stdDevs}Ïƒ OR ${threshold}% distribution<br>
                            <em class="text-yellow-300">Colors within typical ranges will be filtered</em><br>
                            <span class="text-gray-400">To ${globalFilterEnabled ? 'disable' : 'enable'}: ${globalFilterEnabled ? 'uncheck' : 'check'} checkbox above</span>
                            </div>
                        `;
                        infoEl.classList.remove('hidden');

                        updateStatus("Global distribution analysis complete! " + (globalFilterEnabled ? "Filter active." : "Enable checkbox to use."), "text-green-400");
                        
                        if (!isProcessing) processSingleFrame();
                    };
                    
                    video.addEventListener('seeked', restoreHandler, { once: true });
                    video.currentTime = savedTime;
                    return;
                }
                
                const seekTime = frameIndex * frameStep;
                
                const onSeekedHandler = () => {
                    video.removeEventListener('seeked', onSeekedHandler);
                    
                    try {
                        cap.read(srcMat);
                        cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                        cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);
                        
                        // Sample pixels uniformly
                        const h = hsvMat.rows;
                        const w = hsvMat.cols;
                        const step = 20;
                        
                        for (let y = 0; y < h; y += step) {
                            for (let x = 0; x < w; x += step) {
                                const hue = hsvMat.ucharPtr(y, x)[0];
                                const sat = hsvMat.ucharPtr(y, x)[1];
                                const val = hsvMat.ucharPtr(y, x)[2];
                                
                                // Include all pixels to build complete distribution
                                hueValues.push(hue);
                                satValues.push(sat);
                                valValues.push(val);
                            }
                        }
                        
                        frameIndex++;
                        updateStatus(`Analyzing global distribution... ${frameIndex}/${sampleFrames}`, "text-purple-400");
                        
                        setTimeout(sampleNextFrame, 50);
                        
                    } catch (err) {
                        console.error("Error during global distribution analysis:", err);
                        updateStatus("Error during global distribution analysis", "text-red-400");
                        isSeekingSuppressed = false;
                        video.currentTime = savedTime;
                    }
                };
                
                video.addEventListener('seeked', onSeekedHandler, { once: true });
                video.currentTime = Math.min(seekTime, duration - 0.1);
            }
            
            sampleNextFrame();
        }
        
        
        function updateGlobalPreview() {
            const canvas = document.getElementById('global-preview-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = 360;
            canvas.height = 256;
            canvas.classList.remove('hidden');
            
            const dist = globalHsvDistribution;
            const stdDevs = parseFloat(document.getElementById('global-std').value) || 2.0;
            
            // Draw all HSV colors
            for (let h = 0; h < 180; h++) {
                for (let s = 0; s < 256; s++) {
                    const hueInRange = Math.abs(h - dist.hueMean) <= (stdDevs * dist.hueStd);
                    const satInRange = Math.abs(s - dist.satMean) <= (stdDevs * dist.satStd);
                    
                    const hueInPercentile = h >= dist.hueMin && h <= dist.hueMax;
                    const satInPercentile = s >= dist.satMin && s <= dist.satMax;
                    
                    const isExcluded = (hueInRange && satInRange) || (hueInPercentile && satInPercentile);
                    
                    // Convert HSV to RGB for display
                    const rgb = hsvToRgb(h, s, 200);
                    
                    if (isExcluded) {
                        // Dim excluded colors
                        ctx.fillStyle = `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.2)`;
                    } else {
                        // Bright for included colors
                        ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    }
                    
                    ctx.fillRect(h * 2, s, 2, 1);
                }
            }
            
            // Draw distribution boundaries
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(dist.hueMin * 2, dist.satMin, (dist.hueMax - dist.hueMin) * 2, dist.satMax - dist.satMin);
        }
        
        function hsvToRgb(h, s, v) {
            h = h * 2; // OpenCV uses 0-180, convert to 0-360
            s = s / 255;
            v = v / 255;
            
            const c = v * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = v - c;
            
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            
            return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
        }
        
        function isTypicalColor(hue, sat, val) {
            if (!globalHsvDistribution) return false;
            
            const stdDevs = parseFloat(document.getElementById('global-std').value) || 2.0;
            const dist = globalHsvDistribution;
            
            // Check if within std deviations
            const hueInRange = Math.abs(hue - dist.hueMean) <= (stdDevs * dist.hueStd);
            const satInRange = Math.abs(sat - dist.satMean) <= (stdDevs * dist.satStd);
            const valInRange = Math.abs(val - dist.valMean) <= (stdDevs * dist.valStd);
            
            // Also check if within percentile range
            const hueInPercentile = hue >= dist.hueMin && hue <= dist.hueMax;
            const satInPercentile = sat >= dist.satMin && sat <= dist.satMax;
            const valInPercentile = val >= dist.valMin && val <= dist.valMax;
            
            // Exclude if within EITHER std dev range OR percentile range (aggressive filtering)
            return (hueInRange && satInRange && valInRange) || 
                   (hueInPercentile && satInPercentile && valInPercentile);
        }
        
        function isExcludedColor(hue) {
            for (let range of excludedColorRanges) {
                if (hue >= range.min && hue <= range.max) {
                    return true;
                }
            }
            return false;
        }

        function isNaturalColor(hue, sat, val) {
            // Filter out very low saturation colors (grays, whites, blacks)
            // These are almost never interesting anomalies
            if (sat < 30 || val < 30 || val > 240) {
                return true;
            }

            // Common natural terrain colors with low saturation
            // Browns/Earth tones: Hue 10-30, low-medium saturation
            if (hue >= 10 && hue <= 30 && sat < 120) {
                return true;
            }

            // Greens (vegetation): Hue 30-85, low-medium saturation
            if (hue >= 30 && hue <= 85 && sat < 100) {
                return true;
            }

            // Darker greens/olives: Hue 85-100, low saturation
            if (hue >= 85 && hue <= 100 && sat < 80) {
                return true;
            }

            return false;
        }

        function isTerrainColor(hue, sat) {
            if (!terrainBaseline || !useSmartFilter) return false;

            // Get filter strength (lower = more aggressive)
            const filterStrength = parseFloat(document.getElementById('filter-strength').value);

            // Check if this hue/sat falls within typical terrain ranges
            const hueInRange = Math.abs(hue - terrainBaseline.hueMean) < (terrainBaseline.hueStd * filterStrength);
            const satInRange = Math.abs(sat - terrainBaseline.satMean) < (terrainBaseline.satStd * filterStrength);

            // Percentile-based check (more conservative)
            const huePercentileMargin = (terrainBaseline.hueP75 - terrainBaseline.hueP25) * (filterStrength / 2.0);
            const satPercentileMargin = (terrainBaseline.satP75 - terrainBaseline.satP25) * (filterStrength / 2.0);

            const hueInP25P75 = hue >= (terrainBaseline.hueP25 - huePercentileMargin) &&
                               hue <= (terrainBaseline.hueP75 + huePercentileMargin);
            const satInP25P75 = sat >= (terrainBaseline.satP25 - satPercentileMargin) &&
                               sat <= (terrainBaseline.satP75 + satPercentileMargin);

            // Filter out if BOTH hue and sat match terrain
            // At strength 1.5: moderate filtering
            // At strength 0.5: very aggressive (only extreme outliers pass)
            // At strength 3.0: very lenient (more detections pass)
            return (hueInRange && satInRange) || (hueInP25P75 && satInP25P7Saturated);
        }

        function processSingleFrame() {
            try {
                // Check if video is valid
                if (!cap || !video || !video.videoWidth || !video.videoHeight) {
                    console.warn("Invalid video state, skipping frame");
                    return;
                }
                
                // Check if mats are initialized
                if (!srcMat || !rgbMat || !hsvMat) {
                    console.warn("Mats not initialized, skipping frame");
                    return;
                }
                
                cap.read(srcMat);
                
                // Check if we successfully read a frame
                if (srcMat.empty()) {
                    console.warn("Empty frame, skipping");
                    return;
                }

                cv.cvtColor(srcMat, rgbMat, cv.COLOR_RGBA2RGB);
                cv.cvtColor(rgbMat, hsvMat, cv.COLOR_RGB2HSV);

                const enableHsv = document.getElementById('enable-hsv').checked;
                const enableSat = document.getElementById('enable-sat').checked;

                let hsvCount = 0;
                let satCount = 0;
                let currentDetections = []; // For the list below the canvas

                let outputFrame = srcMat.clone();

                // Multi-HSV Detection with individual options
                if (enableHsv) {
                    // Check which HSV options are enabled
                    const hsvOptions = [
                        { prefix: 'hsv1', color: [0, 255, 0, 255], enabled: document.getElementById('hsv1-enabled')?.checked, mode: document.querySelector('input[name="hsv1-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv2', color: [255, 0, 255, 255], enabled: document.getElementById('hsv2-enabled')?.checked, mode: document.querySelector('input[name="hsv2-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv3', color: [0, 255, 255, 255], enabled: document.getElementById('hsv3-enabled')?.checked, mode: document.querySelector('input[name="hsv3-mode"]:checked')?.value || 'include' },
                        { prefix: 'hsv4', color: [255, 255, 0, 255], enabled: document.getElementById('hsv4-enabled')?.checked, mode: document.querySelector('input[name="hsv4-mode"]:checked')?.value || 'include' }
                    ];

                    // Process each enabled HSV option
                    for (const option of hsvOptions) {
                        if (!option.enabled) continue;

                        const hMin = parseInt(document.getElementById(`${option.prefix}-h-min`)?.value || 0);
                        const hMax = parseInt(document.getElementById(`${option.prefix}-h-max`)?.value || 179);
                        const sMin = parseInt(document.getElementById(`${option.prefix}-s-min`)?.value || 0);
                        const sMax = parseInt(document.getElementById(`${option.prefix}-s-max`)?.value || 255);
                        const vMin = parseInt(document.getElementById(`${option.prefix}-v-min`)?.value || 0);
                        const vMax = parseInt(document.getElementById(`${option.prefix}-v-max`)?.value || 255);
                        const minSize = parseInt(document.getElementById(`${option.prefix}-min-size`)?.value || 200);
                        const maxSize = parseInt(document.getElementById(`${option.prefix}-max-size`)?.value || 20000);

                        let lowMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [hMin, sMin, vMin, 0]);
                        let highMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [hMax, sMax, vMax, 0]);

                        let optionMask = new cv.Mat();
                        cv.inRange(hsvMat, lowMat, highMat, optionMask);

                        lowMat.delete();
                        highMat.delete();

                        // If exclude mode, invert the mask
                        if (option.mode === 'exclude') {
                            cv.bitwise_not(optionMask, optionMask);
                        }

                        // Properly clean up old contours before creating new ones
                        if (contours) {
                            for (let i = 0; i < contours.size(); ++i) {
                                contours.get(i).delete();
                            }
                            contours.delete();
                        }
                        contours = new cv.MatVector();

                        cv.findContours(optionMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                        for (let i = 0; i < contours.size(); ++i) {
                            const contour = contours.get(i);
                            const area = cv.contourArea(contour, false);

                            if (area >= minSize && area <= maxSize) {
                                let rect = cv.boundingRect(contour);

                                // Sample the center of the detection
                                const cx = rect.x + Math.floor(rect.width / 2);
                                const cy = rect.y + Math.floor(rect.height / 2);

                                let skipDetection = false;

                                if (cx < hsvMat.cols && cy < hsvMat.rows) {
                                    const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                    const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                    const detVal = hsvMat.ucharPtr(cy, cx)[2];

                                    // Check if color is excluded (old system)
                                    if (isExcludedColor(detHue)) skipDetection = true;

                                    // Smart filter: skip if it looks like terrain
                                    if (useSmartFilter && isTerrainColor(detHue, detSat)) skipDetection = true;
                                    
                                    // Global filter: skip if within typical distribution
                                    if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) skipDetection = true;
                                }

                                if (skipDetection) continue;

                                hsvCount++;

                                let p1 = new cv.Point(rect.x, rect.y);
                                let p2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                                cv.rectangle(outputFrame, p1, p2, option.color, 2, cv.LINE_AA, 0);

                                // Add label with hue and area
                                const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                let colorName = getColorName(detHue);
                                let label = `${option.prefix.toUpperCase()}:${colorName} H${detHue} S${detSat} ${Math.round(area)}px`;
                                cv.putText(outputFrame, label, new cv.Point(rect.x, rect.y - 5),
                                    cv.FONT_HERSHEY_SIMPLEX, 0.4, option.color, 1, cv.LINE_AA);
                                    
                                currentDetections.push({
                                    type: option.prefix.toUpperCase(),
                                    desc: `${colorName} H${detHue} S${detSat}`,
                                    area: Math.round(area)
                                });
                            }
                        }

                        optionMask.delete();
                    }

                }

                // High Saturation Detection
                if (enableSat) {
                    const satMin = parseInt(document.getElementById('sat-min').value, 10);
                    const minSize = parseInt(document.getElementById('sat-min-size').value, 10);
                    const maxSize = parseInt(document.getElementById('sat-max-size').value, 10);

                    let satChannel = new cv.MatVector();
                    cv.split(hsvMat, satChannel);
                    let sat = satChannel.get(1);

                    let satMask = new cv.Mat();
                    let satLow = new cv.Mat(sat.rows, sat.cols, sat.type(), new cv.Scalar(satMin));
                    let satHigh = new cv.Mat(sat.rows, sat.cols, sat.type(), new cv.Scalar(255));
                    cv.inRange(sat, satLow, satHigh, satMask);

                    satLow.delete();
                    satHigh.delete();
                    sat.delete();
                    satChannel.delete();

                    // Properly clean up old contours
                    if (contours) {
                        for (let i = 0; i < contours.size(); ++i) {
                            contours.get(i).delete();
                        }
                        contours.delete();
                    }
                    contours = new cv.MatVector();

                    cv.findContours(satMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                    for (let i = 0; i < contours.size(); ++i) {
                        const contour = contours.get(i);
                        const area = cv.contourArea(contour, false);

                        if (area >= minSize && area <= maxSize) {
                            let rect = cv.boundingRect(contour);
                            const cx = rect.x + Math.floor(rect.width / 2);
                            const cy = rect.y + Math.floor(rect.height / 2);

                            if (cx < hsvMat.cols && cy < hsvMat.rows) {
                                const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                const detVal = hsvMat.ucharPtr(cy, cx)[2];

                                // Check if color is excluded
                                if (isExcludedColor(detHue)) continue;

                                // Smart filter check
                                if (useSmartFilter && isTerrainColor(detHue, detSat)) continue;
                                
                                // Global filter check
                                if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) continue;
                            }

                            satCount++;

                            let p1 = new cv.Point(rect.x, rect.y);
                            let p2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                            cv.rectangle(outputFrame, p1, p2, [255, 0, 255, 255], 2, cv.LINE_AA, 0);

                            // Add label (cx, cy already declared above)
                            const detSat = hsvMat.ucharPtr(cy, cx)[1];
                            let label = `SAT:${detSat} ${Math.round(area)}px`;
                            cv.putText(outputFrame, label, new cv.Point(rect.x, rect.y - 5),
                                cv.FONT_HERSHEY_SIMPLEX, 0.4, [255, 0, 255, 255], 1, cv.LINE_AA);
                                
                            currentDetections.push({
                                type: 'Sat',
                                desc: `S${detSat}`,
                                area: Math.round(area)
                            });
                        }
                    }
                    
                    satMask.delete();
                }
                // DBSCAN Detection
                if (document.getElementById('use-dbscan').checked && window.dbscanAnomalyTargets && window.dbscanAnomalyTargets.length > 0) {
                    
                    for (const target of window.dbscanAnomalyTargets) {
                        let lowMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [target.hMin, target.sMin, target.vMin, 0]);
                        let highMat = new cv.Mat(hsvMat.rows, hsvMat.cols, hsvMat.type(), [target.hMax, target.sMax, target.vMax, 0]);

                        let dbscanMask = new cv.Mat();
                        cv.inRange(hsvMat, lowMat, highMat, dbscanMask);
                        
                        lowMat.delete();
                        highMat.delete();

                        if (contours) {
                            for (let i = 0; i < contours.size(); ++i) contours.get(i).delete();
                            contours.delete();
                        }
                        contours = new cv.MatVector();

                        cv.findContours(dbscanMask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

                        for (let i = 0; i < contours.size(); ++i) {
                            const contour = contours.get(i);
                            const area = cv.contourArea(contour, false);

                            if (area >= target.minSize && area <= target.maxSize) {
                                let rect = cv.boundingRect(contour);
                                const cx = rect.x + Math.floor(rect.width / 2);
                                const cy = rect.y + Math.floor(rect.height / 2);

                                let skipDetection = false;
                                if (cx < hsvMat.cols && cy < hsvMat.rows) {
                                    const detHue = hsvMat.ucharPtr(cy, cx)[0];
                                    const detSat = hsvMat.ucharPtr(cy, cx)[1];
                                    const detVal = hsvMat.ucharPtr(cy, cx)[2];
                                    
                                    // Smart filter check
                                    if (useSmartFilter && isTerrainColor(detHue, detSat)) skipDetection = true;
                                    
                                    // Global filter check
                                    if (enableGlobalFilter && isTypicalColor(detHue, detSat, detVal)) skipDetection = true;
                                }

                                if (skipDetection) continue;

                                // Draw detection (Deep Sky Blue color)
                                let p1 = new cv.Point(rect.x, rect.y);
                                let p2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                                cv.rectangle(outputFrame, p1, p2, [0, 191, 255, 255], 2, cv.LINE_AA, 0);

                                // Add label
                                let label = `${target.label} ${Math.round(area)}px`;
                                cv.putText(outputFrame, label, new cv.Point(rect.x, rect.y - 5),
                                    cv.FONT_HERSHEY_SIMPLEX, 0.4, [0, 191, 255, 255], 1, cv.LINE_AA);
                                    
                                currentDetections.push({
                                    type: 'DBSCAN',
                                    desc: target.label,
                                    area: Math.round(area)
                                });
                            }
                        }
                        dbscanMask.delete();
                    }
                }

                cv.imshow('canvas-out', outputFrame);
                outputFrame.delete();
                
                // Update the list below the canvas
                updateCurrentFrameDetections(currentDetections);

            } catch (err) {
                console.error("OpenCV processing error:", err);
                
                // Try to recover gracefully
                const errorString = err.toString();
                
                if (errorString.includes("Assertion") || errorString.includes("empty")) {
                    console.warn("Recoverable error, attempting to continue...");
                    // Don't stop processing, just skip this frame
                    return;
                }
                
                // For serious errors, try to reinitialize
                if (srcMat && rgbMat && hsvMat) {
                    try {
                        if (!srcMat.isDeleted()) srcMat.delete();
                        if (!rgbMat.isDeleted()) rgbMat.delete();
                        if (!hsvMat.isDeleted()) hsvMat.delete();
                        if (!maskMat.isDeleted()) maskMat.delete();

                        srcMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
                        rgbMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
                        hsvMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC3);
                        maskMat = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);

                        console.log("Mats reinitialized successfully");
                        return; // Continue processing
                    } catch (reinitErr) {
                        console.error("Failed to reinitialize:", reinitErr);
                    }
                }
                
                // Only stop if we can't recover
                pauseProcessing();
                updateStatus(`Error: Processing stopped. Try reloading video.`, "text-red-400");
            }
        }
        
        function getColorName(hue) {
            if (hue <= 10 || hue >= 170) return "Red";
            if (hue <= 25) return "Orange";
            if (hue <= 35) return "Yellow";
            if (hue <= 85) return "Green";
            if (hue <= 125) return "Cyan";
            if (hue <= 155) return "Blue";
            return "Purple";
        }
        
        function updateStatus(message, colorClass) {
            const statusEl = document.getElementById('status-msg');
            statusEl.textContent = `Status: ${message}`;
            statusEl.className = `mb-4 ${colorClass}`;
        }
        
        // --- NEW FUNCTION ---
        function drawDbscanPreview() {
            if (!dbscanPreviewData) {
                alert('Please run "Quick Analyze" with DBSCAN enabled first.');
                return;
            }

            const canvas = document.getElementById('dbscan-preview-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = 360; // Hue (0-179 * 2)
            canvas.height = 256; // Saturation (0-255)
            canvas.classList.remove('hidden');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1f2937'; // bg-gray-800
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const { pixels, labels, numClusters } = dbscanPreviewData;

            // Generate some distinct colors for clusters
            const clusterColors = [
                '#34d399', // Emerald 500
                '#f87171', // Red 500
                '#60a5fa', // Blue 500
                '#facc15', // Yellow 500
                '#38bdf8', // Cyan 500
                '#c084fc', // Purple 500
                '#fb923c', // Orange 500
            ];

            // First, draw noise pixels
            ctx.fillStyle = 'rgba(107, 114, 128, 0.2)'; // gray-500 with alpha
            for (let i = 0; i < pixels.length; i++) {
                if (labels[i] === -1) {
                    const x = pixels[i].hue * 2;
                    const y = 255 - pixels[i].sat; // Invert Y so high-sat is at the top
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // Then, draw clustered pixels
            for (let i = 0; i < pixels.length; i++) {
                const label = labels[i];
                if (label !== -1) {
                    const x = pixels[i].hue * 2;
                    const y = 255 - pixels[i].sat; // Invert Y so high-sat is at the top
                    
                    ctx.fillStyle = clusterColors[label % clusterColors.length];
                    ctx.fillRect(x, y, 2, 2);
                }
            }
            
            // Add labels
            ctx.fillStyle = '#d1d5db'; // gray-300
            ctx.font = '10px sans-serif';
            ctx.fillText('Hue (0-179)', canvas.width / 2 - 20, canvas.height - 5);
            ctx.save();
            ctx.translate(10, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Saturation (0-255)', -40, 0);
            ctx.restore();

            updateStatus(`DBSCAN Preview: ${numClusters} clusters found.`, "text-indigo-400");
        }
        // --- END NEW FUNCTION ---
    </script>

</body>
</html>
